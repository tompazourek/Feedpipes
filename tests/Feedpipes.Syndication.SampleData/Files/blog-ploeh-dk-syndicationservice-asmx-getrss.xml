<?xml version="1.0"?>
<rss version="2.0">

  <channel>
    <title>ploeh blog</title>
    <link>https://blog.ploeh.dk</link>
    <description>danish software design</description>
    <language>en-us</language>
    <copyright>Mark Seemann</copyright>
    <pubDate>Mon, 22 Jul 2019 14:11:54 UTC</pubDate>
    <lastBuildDate>Mon, 22 Jul 2019 14:11:54 UTC</lastBuildDate>

    
      <item>
        <title>Chain of Responsibility as catamorphisms</title>
        <link>https://blog.ploeh.dk/2019/07/22/chain-of-responsibility-as-catamorphisms/</link>
        <pubDate>Mon, 22 Jul 2019 14:11:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;The Chain of Responsibility design pattern can be viewed as a list fold over the First monoid, followed by a Maybe fold.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This article is part of &lt;a href=&quot;/2018/03/05/some-design-patterns-as-universal-abstractions&quot;&gt;a series of articles about specific design patterns and their category theory counterparts&lt;/a&gt;. In it, you'll see how the &lt;a href=&quot;https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern&quot;&gt;Chain of Responsibility design pattern&lt;/a&gt; is equivalent to a succession of &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;catamorphisms&lt;/a&gt;. First, you apply the &lt;a href=&quot;/2018/04/03/maybe-monoids&quot;&gt;First Maybe monoid&lt;/a&gt; over the &lt;a href=&quot;/2019/05/27/list-catamorphism&quot;&gt;list catamorphism&lt;/a&gt;, and then you conclude the reduction with the &lt;a href=&quot;/2019/05/20/maybe-catamorphism&quot;&gt;Maybe catamorphism&lt;/a&gt;.
	&lt;/p&gt;
	&lt;h3 id=&quot;46a6c41949db446d9387c8befbf3fdb1&quot;&gt;
		Pattern &lt;a href=&quot;#46a6c41949db446d9387c8befbf3fdb1&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The Chain of Responsibility design pattern gives you a way to model cascading conditionals with an object structure. It's a chain (or linked list) of objects that all implement the same interface (or base class). Each object (apart from the the last) has a reference to the next object in the list.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/chain-of-responsibility-diagram.png&quot; alt=&quot;General diagram of the Chain of Responsibility design pattern.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		A client (some other code) calls a method on the first object in the list. If that object can handle the request, it does so, and the interaction ends there. If the method returns a value, the object returns the value.
	&lt;/p&gt;
	&lt;p&gt;
		If the first object determines that it can't handle the method call, it calls the next object in the chain. It only knows the next object as the interface, so the only way it can delegate the call is by calling the same method as the first one. In the above diagram, &lt;em&gt;Imp1&lt;/em&gt; can't handle the method call, so it calls the same method on &lt;em&gt;Imp2&lt;/em&gt;, which also can't handle the request and delegates responsibility to &lt;em&gt;Imp3&lt;/em&gt;. In the diagram, &lt;em&gt;Imp3&lt;/em&gt; can handle the method call, so it does so and returns a result that propagates back up the chain. In that particular example, &lt;em&gt;Imp4&lt;/em&gt; never gets involved.
	&lt;/p&gt;
	&lt;p&gt;
		You'll see an example below.
	&lt;/p&gt;
	&lt;p&gt;
		One of the advantages of the pattern is that you can rearrange the chain to change its behaviour. You can even do this at run time, if you'd like, since all objects implement the same interface.
	&lt;/p&gt;
	&lt;h3 id=&quot;08a67dafd71f4bdd9a2e2577b0e43f9a&quot;&gt;
		User icon example &lt;a href=&quot;#08a67dafd71f4bdd9a2e2577b0e43f9a&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Consider an online system that maintains user profiles for users. A user is modelled with the &lt;code&gt;User&lt;/code&gt; class:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;User(&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;id,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;name,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;email,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;useGravatar,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;useIdenticon)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While I only show the signature of the class' constructor, it should be enough to give you an idea. If you need more details, the entire example code base is &lt;a href=&quot;https://github.com/ploeh/UserProfile&quot;&gt;available on GitHub&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		Apart from an &lt;code&gt;id&lt;/code&gt;, a &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; address, a user also has two flags. One flag tracks whether the user wishes to use his or her &lt;a href=&quot;http://www.gravatar.com&quot;&gt;Gravatar&lt;/a&gt;, while another flag tracks if the user would like to use an &lt;a href=&quot;https://en.wikipedia.org/wiki/Identicon&quot;&gt;Identicon&lt;/a&gt;. Obviously, both flags could be &lt;code&gt;true&lt;/code&gt;, in which case the current business rule states that the Gravatar should take precedence.
	&lt;/p&gt;
	&lt;p&gt;
		If none of the flags are set, users might still have a picture associated with their profile. This could be a picture that they've uploaded to the system, and is being tracked by a database.
	&lt;/p&gt;
	&lt;p&gt;
		If no user icon can be found or generated, ultimately the system should use a fallback, default icon:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/default-user-icon.png&quot; alt=&quot;Default user icon.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		To summarise, the current rules are:
		&lt;ol&gt;
			&lt;li&gt;Use Gravatar if flag is set.&lt;/li&gt;
			&lt;li&gt;Use Identicon if flag is set.&lt;/li&gt;
			&lt;li&gt;Use uploaded picture if available.&lt;/li&gt;
			&lt;li&gt;Use default icon.&lt;/li&gt;
		&lt;/ol&gt;
		The order of precedence could change in the future, new images sources could be added, or some of the present sources could be removed. Modelling this set of rules as a Chain of Responsibility makes it easy for you to reorder the rules, should you need to.
	&lt;/p&gt;
	&lt;p&gt;
		To request an icon, a client can use the &lt;code&gt;IIconReader&lt;/code&gt; interface:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Icon&lt;/code&gt; class is just a &lt;a href=&quot;https://martinfowler.com/bliki/ValueObject.html&quot;&gt;Value Object&lt;/a&gt; wrapper around a URL. The idea is that such a URL can be used in an &lt;code&gt;img&lt;/code&gt; tag to show the icon. Again, the full source code is available on GitHub if you'd like to investigate the details.
	&lt;/p&gt;
	&lt;p&gt;
		The various rules for icon retrieval can be implemented using this interface.
	&lt;/p&gt;
	&lt;h3 id=&quot;b2a4cbfb576949c392ea0e0b3d440175&quot;&gt;
		Gravatar reader &lt;a href=&quot;#b2a4cbfb576949c392ea0e0b3d440175&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Although you don't have to implement the classes in the order in which you are going to compose them, it seems natural to do so, starting with the Gravatar implementation.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;class&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;GravatarReader&lt;/span&gt;&amp;nbsp;:&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;nbsp;next;
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;GravatarReader(&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;nbsp;next)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;.next&amp;nbsp;=&amp;nbsp;next;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(user.UseGravatar)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Gravatar&lt;/span&gt;(user.Email).Url);
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;next.ReadIcon(user);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;GravatarReader&lt;/code&gt; class both implements the &lt;code&gt;IIconReader&lt;/code&gt; interface, but also decorates another object of the same polymorphic type. If &lt;code&gt;user.UseGravatar&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it generates the appropriate Gravatar URL based on the user's &lt;code&gt;Email&lt;/code&gt; address; otherwise, it delegates the work to the &lt;code&gt;next&lt;/code&gt; object in the Chain of Responsibility.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Gravatar&lt;/code&gt; class contains the implementation details to generate the Gravatar &lt;code&gt;Url&lt;/code&gt;. Again, please refer to the GitHub repository if you're interested in the details.
	&lt;/p&gt;
	&lt;h3 id=&quot;222ae025b264455695f1dbbd74cad17b&quot;&gt;
		Identicon reader &lt;a href=&quot;#222ae025b264455695f1dbbd74cad17b&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		When you compose the chain, according to the above business logic, the next type of icon you should attempt to generate is an Identicon. It's natural to implement the Identicon reader next, then:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;class&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IdenticonReader&lt;/span&gt;&amp;nbsp;:&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;nbsp;next;
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;IdenticonReader(&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;nbsp;next)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;.next&amp;nbsp;=&amp;nbsp;next;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(user.UseIdenticon)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Uri&lt;/span&gt;(baseUrl,&amp;nbsp;HashUser(user)));
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;next.ReadIcon(user);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:green;&quot;&gt;//&amp;nbsp;Implementation&amp;nbsp;details&amp;nbsp;go&amp;nbsp;here...&lt;/span&gt;
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Again, I'm omitting implementation details in order to focus on the Chain of Responsibility design pattern. If &lt;code&gt;user.UseIdenticon&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IdenticonReader&lt;/code&gt; generates the appropriate Identicon and returns the URL for it; otherwise, it delegates the work to the &lt;code&gt;next&lt;/code&gt; object in the chain.
	&lt;/p&gt;
	&lt;h3 id=&quot;e9f2904333b940c1a9a90522d19a41f3&quot;&gt;
		Database icon reader &lt;a href=&quot;#e9f2904333b940c1a9a90522d19a41f3&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The &lt;code&gt;DBIconReader&lt;/code&gt; class attempts to find an icon ID in a database. If it succeeds, it creates a URL corresponding to that ID. The assumption is that that resource exists; either it's a file on disk, or it's an image resource generated on the spot based on binary data stored in the database.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;class&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DBIconReader&lt;/span&gt;&amp;nbsp;:&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IUserRepository&lt;/span&gt;&amp;nbsp;repository;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;nbsp;next;
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;DBIconReader(&lt;span style=&quot;color:#2b91af;&quot;&gt;IUserRepository&lt;/span&gt;&amp;nbsp;repository,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;nbsp;next)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;.repository&amp;nbsp;=&amp;nbsp;repository;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;.next&amp;nbsp;=&amp;nbsp;next;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(!repository.TryReadIconId(user.Id,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;out&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;iconId))
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;next.ReadIcon(user);
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;parameters&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Dictionary&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;iconId&amp;quot;&lt;/span&gt;,&amp;nbsp;iconId&amp;nbsp;}
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;(urlTemplate.BindByName(baseUrl,&amp;nbsp;parameters));
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Uri&lt;/span&gt;&amp;nbsp;baseUrl&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Uri&lt;/span&gt;(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;https://example.com&amp;quot;&lt;/span&gt;);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;UriTemplate&lt;/span&gt;&amp;nbsp;urlTemplate&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;UriTemplate&lt;/span&gt;(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;users/{iconId}/icon&amp;quot;&lt;/span&gt;);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This class demonstrates some variations in the way you can implement the Chain of Responsibility design pattern. The above &lt;code&gt;GravatarReader&lt;/code&gt; and &lt;code&gt;IdenticonReader&lt;/code&gt; classes both follow the same implementation pattern of checking a condition, and then performing work if the condition is &lt;code&gt;true&lt;/code&gt;. The delegation to the next object in the chain happens, in those two classes, outside of the &lt;code&gt;if&lt;/code&gt; statement.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;DBIconReader&lt;/code&gt; class, on the other hand, reverses the structure of the code. It uses a &lt;a href=&quot;https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html&quot;&gt;Guard Clause&lt;/a&gt; to detect whether to exit early, which is done by delegating work to the &lt;code&gt;next&lt;/code&gt; object in the chain.
	&lt;/p&gt;
	&lt;p&gt;
		If &lt;code&gt;TryReadIconId&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, however, the &lt;code&gt;ReadIcon&lt;/code&gt; method proceeds to create the appropriate icon URL.
	&lt;/p&gt;
	&lt;p&gt;
		Another variation on the Chain of Responsibility design pattern demonstrated by the &lt;code&gt;DBIconReader&lt;/code&gt; class is that it takes a second dependency, apart from &lt;code&gt;next&lt;/code&gt;. The &lt;code&gt;repository&lt;/code&gt; is the usual misapplication of the Repository design pattern that everyone think they use correctly. Here, it's used in the common sense to provide access to a database. The main point, though, is that you can add as many other dependencies to a link in the chain as you'd like. All links, apart from the last, however, must have a reference to the &lt;code&gt;next&lt;/code&gt; link in the chain.
	&lt;/p&gt;
	&lt;h3 id=&quot;cee40120578b4732892e6fd72329d5de&quot;&gt;
		Default icon reader &lt;a href=&quot;#cee40120578b4732892e6fd72329d5de&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Like linked lists, a Chain of Responsibility has to ultimately terminate. You can use the following &lt;code&gt;DefaultIconReader&lt;/code&gt; for that.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;class&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DefaultIconReader&lt;/span&gt;&amp;nbsp;:&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;.Default;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This class unconditionally returns the &lt;code&gt;Default&lt;/code&gt; icon. Notice that it doesn't have any &lt;code&gt;next&lt;/code&gt; object it delegates to. This terminates the chain. If no previous implementation of the &lt;code&gt;IIconReader&lt;/code&gt; has returned an &lt;code&gt;Icon&lt;/code&gt; for the &lt;code&gt;user&lt;/code&gt;, this one does.
	&lt;/p&gt;
	&lt;h3 id=&quot;8eb05bed2d98488a91c09bab52b00a53&quot;&gt;
		Chain composition &lt;a href=&quot;#8eb05bed2d98488a91c09bab52b00a53&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		With four implementations of &lt;code&gt;IIconReader&lt;/code&gt;, you can now compose the Chain of Responsibility:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;nbsp;reader&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;GravatarReader&lt;/span&gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IdenticonReader&lt;/span&gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DBIconReader&lt;/span&gt;(repo,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DefaultIconReader&lt;/span&gt;())));&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The first link in the chain is a &lt;code&gt;GravatarReader&lt;/code&gt; object that contains an &lt;code&gt;IdenticonReader&lt;/code&gt; object as its &lt;code&gt;next&lt;/code&gt; link, and so on. Referring back to the source code of &lt;code&gt;GravatarReader&lt;/code&gt;, notice that its &lt;code&gt;next&lt;/code&gt; dependency is declared as an &lt;code&gt;IIconReader&lt;/code&gt;. Since the &lt;code&gt;IdenticonReader&lt;/code&gt; class implements that interface, you can compose the chain like this, but if you later decide to change the order of the objects, you can do so simply by changing the composition. You could remove objects altogether, or add new classes, and you could even do this at run time, if required.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;DBIconReader&lt;/code&gt; class requires an extra &lt;code&gt;IUserRepository&lt;/code&gt; dependency, here simply an existing object called &lt;code&gt;repo&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;DefaultIconReader&lt;/code&gt; takes no other dependencies, so this effectively terminates the chain. If you try to pass another &lt;code&gt;IIconReader&lt;/code&gt; to its constructor, the code doesn't compile.
	&lt;/p&gt;
	&lt;h3 id=&quot;fc1551665bb940b8ba5e75be81c0629a&quot;&gt;
		Haskell proof of concept &lt;a href=&quot;#fc1551665bb940b8ba5e75be81c0629a&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		When evaluating whether a design is &lt;a href=&quot;/2018/11/19/functional-architecture-a-definition&quot;&gt;a functional architecture&lt;/a&gt;, I often port the relevant parts to &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;. You can do the same with the above example, and put it in a form where it's clearer that the Chain of Responsibility pattern is equivalent to two well-known catamorphisms.
	&lt;/p&gt;
	&lt;p&gt;
		Readers not comfortable with Haskell can skip the next few sections. The object-oriented example continues below.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Icon&lt;/code&gt; types are defined by types equivalent to above. There's no explicit interface, however. Creation of Gravatars and Identicons are both pure functions with the type &lt;code&gt;User -&amp;gt; Maybe Icon&lt;/code&gt;. Here's the Gravatar function, but the Identicon function looks similar:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;gravatarUrl&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;String&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;String&lt;/span&gt;
gravatarUrl&amp;nbsp;email&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;https://www.gravatar.com/avatar/&amp;quot;&lt;/span&gt;&amp;nbsp;++&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;show&lt;/span&gt;&amp;nbsp;(hashString&amp;nbsp;email&amp;nbsp;::&amp;nbsp;MD5Digest)
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;getGravatar&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;User&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Icon&lt;/span&gt;
getGravatar&amp;nbsp;u&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;useGravatar&amp;nbsp;u
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;then&lt;/span&gt;&amp;nbsp;Just&amp;nbsp;$&amp;nbsp;Icon&amp;nbsp;$&amp;nbsp;gravatarUrl&amp;nbsp;$&amp;nbsp;userEmail&amp;nbsp;u
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;else&lt;/span&gt;&amp;nbsp;Nothing&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Reading an icon ID from a database, however, is an impure operation, so the function to do this has the type &lt;code&gt;User -&amp;gt; IO (Maybe Icon)&lt;/code&gt;.
	&lt;/p&gt;
	&lt;h3 id=&quot;11adf8bd104d41fab9e6bcaef249210c&quot;&gt;
		Lazy I/O in Haskell &lt;a href=&quot;#11adf8bd104d41fab9e6bcaef249210c&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Notice that the database icon-querying function has the return type &lt;code&gt;IO (Maybe Icon)&lt;/code&gt;. In the introduction you read that the Chain of Responsibility design pattern is a sequence of catamorphisms - the first one over a list of &lt;code&gt;First&lt;/code&gt; values. While &lt;code&gt;First&lt;/code&gt; is, in itself, a &lt;code&gt;Semigroup&lt;/code&gt; instance, it gives rise to a &lt;code&gt;Monoid&lt;/code&gt; instance when combined with &lt;code&gt;Maybe&lt;/code&gt;. Thus, to showcase the abstractions being used, you could create a list of &lt;code&gt;Maybe (First Icon)&lt;/code&gt; values. This forms a &lt;code&gt;Monoid&lt;/code&gt;, so is easy to fold.
	&lt;/p&gt;
	&lt;p&gt;
		The problem with that, however, is that &lt;code&gt;IO&lt;/code&gt; is strict under evaluation, so while it works, &lt;a href=&quot;https://stackoverflow.com/q/47120384/126014&quot;&gt;it's no longer lazy&lt;/a&gt;. You can combine &lt;code&gt;IO (Maybe (First Icon))&lt;/code&gt; values, but it leads to too much I/O activity.
	&lt;/p&gt;
	&lt;p&gt;
		You can &lt;a href=&quot;https://stackoverflow.com/q/47120384/126014&quot;&gt;solve this problem with a newtype wrapper&lt;/a&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;newtype&lt;/span&gt;&amp;nbsp;FirstIO&amp;nbsp;a&amp;nbsp;=&amp;nbsp;FirstIO&amp;nbsp;(MaybeT&amp;nbsp;IO&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Functor&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Applicative&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Monad&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Alternative&lt;/span&gt;)
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;firstIO&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IO&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FirstIO&lt;/span&gt;&amp;nbsp;a
firstIO&amp;nbsp;=&amp;nbsp;FirstIO&amp;nbsp;.&amp;nbsp;MaybeT
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;getFirstIO&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FirstIO&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IO&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;a)
getFirstIO&amp;nbsp;(FirstIO&amp;nbsp;(MaybeT&amp;nbsp;x))&amp;nbsp;=&amp;nbsp;x
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Semigroup&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;FirstIO&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;(&amp;lt;&amp;gt;)&lt;/span&gt;&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;(&amp;lt;|&amp;gt;)&lt;/span&gt;
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Monoid&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;FirstIO&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;mempty&amp;nbsp;=&amp;nbsp;empty&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This uses the &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; GHC extension to automatically make &lt;code&gt;FirstIO&lt;/code&gt; &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Monad&lt;/code&gt;, and &lt;code&gt;Alternative&lt;/code&gt;. It also uses the &lt;code&gt;Alternative&lt;/code&gt; instance to implement &lt;code&gt;Semigroup&lt;/code&gt; and &lt;code&gt;Monoid&lt;/code&gt;. You may recall from &lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Control-Applicative.html&quot;&gt;the documentation&lt;/a&gt; that &lt;code&gt;Alternative&lt;/code&gt; is already a &quot;monoid on applicative functors.&quot;
	&lt;/p&gt;
	&lt;h3 id=&quot;995f9ea8f8344aea93b2ffd0b3aad71f&quot;&gt;
		Alignment &lt;a href=&quot;#995f9ea8f8344aea93b2ffd0b3aad71f&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You now have three functions with different types: two pure functions with the type &lt;code&gt;User -&amp;gt; Maybe Icon&lt;/code&gt; and one impure database-bound function with the type &lt;code&gt;User -&amp;gt; IO (Maybe Icon)&lt;/code&gt;. In order to have a common abstraction, you should align them so that all types match. At first glance, &lt;code&gt;User -&amp;gt; IO (Maybe (First Icon))&lt;/code&gt; seems like a type that fits all implementations, but that causes too much I/O to take place, so instead, use &lt;code&gt;User -&amp;gt; FirstIO Icon&lt;/code&gt;. Here's how to lift the pure &lt;code&gt;getGravatar&lt;/code&gt; function:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;getGravatarIO&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;User&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FirstIO&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Icon&lt;/span&gt;
getGravatarIO&amp;nbsp;=&amp;nbsp;firstIO&amp;nbsp;.&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;.&amp;nbsp;getGravatar&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can lift the other functions in similar fashion, to produce &lt;code&gt;getGravatarIO&lt;/code&gt;, &lt;code&gt;getIdenticonIO&lt;/code&gt;, and &lt;code&gt;getDBIconIO&lt;/code&gt;, all with the mutual type &lt;code&gt;User -&amp;gt; FirstIO Icon&lt;/code&gt;.
	&lt;/p&gt;
	&lt;h3 id=&quot;f601a51f3006430398232e05b6595da0&quot;&gt;
		Haskell composition &lt;a href=&quot;#f601a51f3006430398232e05b6595da0&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The goal of the Haskell proof of concept is to compose a function that can provide an &lt;code&gt;Icon&lt;/code&gt; for any &lt;code&gt;User&lt;/code&gt; - just like the above C# composition that uses Chain of Responsibility. There's, however, no way around impurity, because one of the steps involve a database, so the aim is a composition with the type &lt;code&gt;User -&amp;gt; IO Icon&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		While a more compact composition is possible, I'll show it in a way that makes the catamorphisms explicit:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;getIcon&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;User&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IO&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Icon&lt;/span&gt;
getIcon&amp;nbsp;u&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;do&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;let&lt;/span&gt;&amp;nbsp;lazyIcons&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;(\f&amp;nbsp;-&amp;gt;&amp;nbsp;f&amp;nbsp;u)&amp;nbsp;[getGravatarIO,&amp;nbsp;getIdenticonIO,&amp;nbsp;getDBIconIO]
&amp;nbsp;&amp;nbsp;m&amp;nbsp;&amp;lt;-&amp;nbsp;getFirstIO&amp;nbsp;$&amp;nbsp;fold&amp;nbsp;lazyIcons
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;$&amp;nbsp;fromMaybe&amp;nbsp;defaultIcon&amp;nbsp;m&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;getIcon&lt;/code&gt; function starts with a list of all three functions. For each of them, it calls the function with the &lt;code&gt;User&lt;/code&gt; value &lt;code&gt;u&lt;/code&gt;. This may seem inefficient and redundant, because all three function calls may not be required, but since the return values are &lt;code&gt;FirstIO&lt;/code&gt; values, all three function calls are lazily evaluated - even under &lt;code&gt;IO&lt;/code&gt;. The result, &lt;code&gt;lazyIcons&lt;/code&gt;, is a &lt;code&gt;[FirstIO Icon]&lt;/code&gt; value; i.e. a lazily evaluated list of lazily evaluated values.
	&lt;/p&gt;
	&lt;p&gt;
		This first step is just to put the potential values in a form that's recognisable. You can now &lt;code&gt;fold&lt;/code&gt; the &lt;code&gt;lazyIcons&lt;/code&gt; to a single &lt;code&gt;FirstIO Icon&lt;/code&gt; value, and then use &lt;code&gt;getFirstIO&lt;/code&gt; to unwrap it. Due to &lt;code&gt;do&lt;/code&gt; notation, &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;Maybe Icon&lt;/code&gt; value.
	&lt;/p&gt;
	&lt;p&gt;
		This is the first catamorphism. Granted, the generalisation that &lt;code&gt;fold&lt;/code&gt; offers is not really required, since &lt;code&gt;lazyIcons&lt;/code&gt; is a list; &lt;code&gt;mconcat&lt;/code&gt; would have worked just as well. I did, however, choose to use &lt;code&gt;fold&lt;/code&gt; (from &lt;code&gt;Data.Foldable&lt;/code&gt;) to emphasise the point. While the &lt;code&gt;fold&lt;/code&gt; function itself isn't the catamorphism for lists, we know that &lt;a href=&quot;/2019/05/27/list-catamorphism&quot;&gt;it's derived from the list catamorphism&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		The final step is to utilise the Maybe catamorphism to reduce the &lt;code&gt;Maybe Icon&lt;/code&gt; value to an &lt;code&gt;Icon&lt;/code&gt; value. Again, the &lt;code&gt;getIcon&lt;/code&gt; function doesn't use the Maybe catamorphism directly, but rather the derived &lt;code&gt;fromMaybe&lt;/code&gt; function. The &lt;a href=&quot;/2019/05/20/maybe-catamorphism&quot;&gt;Maybe catamorphism&lt;/a&gt; is the &lt;code&gt;maybe&lt;/code&gt; function, but you can trivially implement &lt;code&gt;fromMaybe&lt;/code&gt; with &lt;code&gt;maybe&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		For &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_golf&quot;&gt;golfers&lt;/a&gt;, it's certainly possible to write this function in a more compact manner. Here's a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tacit_programming&quot;&gt;point-free&lt;/a&gt; version:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;getIcon&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;User&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IO&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Icon&lt;/span&gt;
getIcon&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;(fromMaybe&amp;nbsp;defaultIcon)&amp;nbsp;.&amp;nbsp;getFirstIO&amp;nbsp;.&amp;nbsp;fold&amp;nbsp;[getGravatarIO,&amp;nbsp;getIdenticonIO,&amp;nbsp;getDBIconIO]&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This alternative version utilises that &lt;code&gt;a -&amp;gt; m&lt;/code&gt; is a &lt;code&gt;Monoid&lt;/code&gt; instance when &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;Monoid&lt;/code&gt; instance. That's the reason that you can &lt;code&gt;fold&lt;/code&gt; a list of functions. The more explicit version above doesn't do that, but the behaviour is the same in both cases.
	&lt;/p&gt;
	&lt;p&gt;
		That's all the Haskell code we need to discern the universal abstractions involved in the Chain of Responsibility design pattern. We can now return to the C# code example.
	&lt;/p&gt;
	&lt;h3 id=&quot;492ff50788784d7dbf6560ed08ed6bf7&quot;&gt;
		Chains as lists &lt;a href=&quot;#492ff50788784d7dbf6560ed08ed6bf7&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The Chain of Responsibility design pattern is often illustrated like above, in a staircase-like diagram. There's, however, no inherent requirement to do so. You could also flatten the diagram:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/chain-of-responsibility-as-a-linked-list.png&quot; alt=&quot;Chain of Responsibility illustrated as a linked list.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This looks a lot like a linked list.
	&lt;/p&gt;
	&lt;p&gt;
		The difference is, however, that the terminator of a linked list is usually empty. Here, however, you have two types of objects. All objects apart from the rightmost object represent a &lt;em&gt;potential&lt;/em&gt;. Each object may, or may not, handle the method call and produce an outcome; if an object can't handle the method call, it'll delegate to the next object in the chain.
	&lt;/p&gt;
	&lt;p&gt;
		The rightmost object, however, is different. This object can't delegate any further, but &lt;em&gt;must&lt;/em&gt; handle the method call. In the icon reader example, this is the &lt;code&gt;DefaultIconReader&lt;/code&gt; class.
	&lt;/p&gt;
	&lt;p&gt;
		Once you start to see most of the list as a list of potential values, you may realise that you'll be able to collapse into it a single potential value. This is possible because &lt;a href=&quot;/2018/04/03/maybe-monoids&quot;&gt;a list of values where you pick the first non-empty value forms a monoid&lt;/a&gt;. This is sometimes called the &lt;em&gt;First&lt;/em&gt; &lt;a href=&quot;/2017/10/06/monoids&quot;&gt;monoid&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		In other words, you can reduce, or fold, all of the list, except the rightmost value, to a single potential value:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/chain-of-responsibility-as-a-linked-list-single-fold.png&quot; alt=&quot;Chain of Responsibility illustrated as a linked list, with all but the rightmost objects folded to one.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		When you do that, however, you're left with a single potential value. The result of folding most of the list is that you get the leftmost non-empty value in the list. There's no guarantee, however, that that value is non-empty. If all the values in the list are empty, the result is also empty. This means that you somehow need to combine a potential value with a value that's guaranteed to be present: the terminator.
	&lt;/p&gt;
	&lt;p&gt;
		You can do that wither another fold:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/chain-of-responsibility-as-a-linked-list-double-fold.png&quot; alt=&quot;Chain of Responsibility illustrated as a linked list, with two consecutive folds.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This second fold isn't a list fold, but rather a Maybe fold.
	&lt;/p&gt;
	&lt;h3 id=&quot;7632b9ff458d417fa49b1c65f7b198ed&quot;&gt;
		Maybe &lt;a href=&quot;#7632b9ff458d417fa49b1c65f7b198ed&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The &lt;em&gt;First&lt;/em&gt; monoid is a monoid over &lt;a href=&quot;/2018/03/26/the-maybe-functor&quot;&gt;Maybe&lt;/a&gt;, so add a &lt;code&gt;Maybe&lt;/code&gt; class to the code base. In Haskell, the catamorphism for Maybe is called &lt;code&gt;maybe&lt;/code&gt;, but that's not a good method name in object-oriented design. Another option is some variation of &lt;em&gt;fold&lt;/em&gt;, but in C#, this functionality tends to be called &lt;code&gt;Aggregate&lt;/code&gt;, at least for &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, so I'll reuse that terminology:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;Aggregate&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;@default,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;func)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(func&amp;nbsp;==&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;null&lt;/span&gt;)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;throw&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;ArgumentNullException&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;nameof&lt;/span&gt;(func));
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;hasItem&amp;nbsp;?&amp;nbsp;func(item)&amp;nbsp;:&amp;nbsp;@default;
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can implement another, more list-like &lt;code&gt;Aggregate&lt;/code&gt; overload from this one, but for this article, you don't need it.
	&lt;/p&gt;
	&lt;h3 id=&quot;8b60d0c605d14cffbfa5e237cf26b7b2&quot;&gt;
		From TryReadIconId to Maybe &lt;a href=&quot;#8b60d0c605d14cffbfa5e237cf26b7b2&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		In the above code examples, &lt;code&gt;DBIconReader&lt;/code&gt; depends on &lt;code&gt;IUserRepository&lt;/code&gt;, which defined this method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;TryReadIconId(&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;userId,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;out&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;iconId);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		From &lt;a href=&quot;/2019/07/15/tester-doer-isomorphisms&quot;&gt;Tester-Doer isomorphisms&lt;/a&gt; we know, however, that such a design is isomorphic to returning a Maybe value, and since that's more composable, do that:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;nbsp;ReadIconId(&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;userId);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This requires you to refactor the &lt;code&gt;DBIconReader&lt;/code&gt; implementation of the &lt;code&gt;ReadIcon&lt;/code&gt; method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;nbsp;mid&amp;nbsp;=&amp;nbsp;repository.ReadIconId(user.Id);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;&amp;nbsp;lazyResult&amp;nbsp;=&amp;nbsp;mid.Aggregate(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;@default:&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;(()&amp;nbsp;=&amp;gt;&amp;nbsp;next.ReadIcon(user)),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;func:&amp;nbsp;id&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;(()&amp;nbsp;=&amp;gt;&amp;nbsp;CreateIcon(id)));
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;lazyResult.Value;
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		A few things are worth a mention. Notice that the above &lt;code&gt;Aggregate&lt;/code&gt; method (the Maybe catamorphism) requires you to supply a &lt;code&gt;@default&lt;/code&gt; value (to be used if the Maybe object is empty). In the Chain of Responsibility design pattern, however, the fallback value is produced by calling the &lt;code&gt;next&lt;/code&gt; object in the chain. If you do this unconditionally, however, you perform too much work. You're only supposed to call &lt;code&gt;next&lt;/code&gt; if the current object can't handle the method call.
	&lt;/p&gt;
	&lt;p&gt;
		The solution is to aggregate the &lt;code&gt;mid&lt;/code&gt; object to a &lt;code&gt;Lazy&amp;lt;Icon&amp;gt;&lt;/code&gt; and then return its &lt;code&gt;Value&lt;/code&gt;. The &lt;code&gt;@default&lt;/code&gt; value is now a lazy computation that calls &lt;code&gt;next&lt;/code&gt; only if its &lt;code&gt;Value&lt;/code&gt; is read. When &lt;code&gt;mid&lt;/code&gt; is populated, on the other hand, the lazy computation calls the private &lt;code&gt;CreateIcon&lt;/code&gt; method when &lt;code&gt;Value&lt;/code&gt; is accessed. The private &lt;code&gt;CreateIcon&lt;/code&gt; method contains the same logic as before the refactoring.
	&lt;/p&gt;
	&lt;p&gt;
		This change of &lt;code&gt;DBIconReader&lt;/code&gt; isn't strictly necessary in order to change the overall Chain of Responsibility to a pair of catamorphisms, but serves, I think, as a nice introduction to the use of the Maybe catamorphism.
	&lt;/p&gt;
	&lt;h3 id=&quot;ec329c8a0b70432d81d6f69e7084c13f&quot;&gt;
		Optional icon readers &lt;a href=&quot;#ec329c8a0b70432d81d6f69e7084c13f&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Previously, the &lt;code&gt;IIconReader&lt;/code&gt; interface &lt;em&gt;required&lt;/em&gt; each implementation to return an &lt;code&gt;Icon&lt;/code&gt; object:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		When you have an object like &lt;code&gt;GravatarReader&lt;/code&gt; that may or may not return an &lt;code&gt;Icon&lt;/code&gt;, this requirement leads toward the Chain of Responsibility design pattern. You can, however, shift the responsibility of what to do next by changing the interface:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;interface&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		An implementation like &lt;code&gt;GravatarReader&lt;/code&gt; becomes simpler:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;class&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;GravatarReader&lt;/span&gt;&amp;nbsp;:&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(user.UseGravatar)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Gravatar&lt;/span&gt;(user.Email).Url));
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		No longer do you have to pass in a &lt;code&gt;next&lt;/code&gt; dependency. Instead, you just return an empty &lt;code&gt;Maybe&amp;lt;Icon&amp;gt;&lt;/code&gt; if you can't handle the method call. The same change applies to the &lt;code&gt;IdenticonReader&lt;/code&gt; class.
	&lt;/p&gt;
	&lt;p&gt;
		Since &lt;a href=&quot;/2018/03/26/the-maybe-functor&quot;&gt;Maybe is a functor&lt;/a&gt;, and the &lt;code&gt;DBIconReader&lt;/code&gt; already works on a &lt;code&gt;Maybe&amp;lt;string&amp;gt;&lt;/code&gt; value, its implementation is greatly simplified:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;repository.ReadIconId(user.Id).Select(CreateIcon);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Since &lt;code&gt;ReadIconId&lt;/code&gt; returns a &lt;code&gt;Maybe&amp;lt;string&amp;gt;&lt;/code&gt;, you can simply use &lt;code&gt;Select&lt;/code&gt; to transform the icon ID to an &lt;code&gt;Icon&lt;/code&gt; object if the Maybe is populated.
	&lt;/p&gt;
	&lt;h3 id=&quot;94cac3b9e52e48c2a1768fd24c72e4bd&quot;&gt;
		Coalescing Composite &lt;a href=&quot;#94cac3b9e52e48c2a1768fd24c72e4bd&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As an intermediate step, you can compose the various readers using a &lt;a href=&quot;/2018/04/09/coalescing-composite-as-a-monoid&quot;&gt;Coalescing Composite&lt;/a&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;class&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;CompositeIconReader&lt;/span&gt;&amp;nbsp;:&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;[]&amp;nbsp;iconReaders;
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;CompositeIconReader(&lt;span style=&quot;color:blue;&quot;&gt;params&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;[]&amp;nbsp;iconReaders)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;.iconReaders&amp;nbsp;=&amp;nbsp;iconReaders;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;foreach&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;iconReader&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;in&lt;/span&gt;&amp;nbsp;iconReaders)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;mIcon&amp;nbsp;=&amp;nbsp;iconReader.ReadIcon(user);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(IsPopulated(mIcon))
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;mIcon;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;IsPopulated&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;m)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;m.Aggregate(&lt;span style=&quot;color:blue;&quot;&gt;false&lt;/span&gt;,&amp;nbsp;_&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;true&lt;/span&gt;);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I prefer a more explicit design over this one, so this is just an intermediate step. This &lt;code&gt;IIconReader&lt;/code&gt; implementation composes an array of other &lt;code&gt;IIconReader&lt;/code&gt; objects and queries each in order to return the first populated Maybe value it finds. If it doesn't find any populated value, it returns an empty Maybe object.
	&lt;/p&gt;
	&lt;p&gt;
		You can now compose your &lt;code&gt;IIconReader&lt;/code&gt; objects into a &lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_pattern&quot;&gt;Composite&lt;/a&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;nbsp;reader&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;CompositeIconReader&lt;/span&gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;GravatarReader&lt;/span&gt;(),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IdenticonReader&lt;/span&gt;(),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DBIconReader&lt;/span&gt;(repo));&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While this gives you a single object on which you can call &lt;code&gt;ReadIcon&lt;/code&gt;, the return value of that method is still a &lt;code&gt;Maybe&amp;lt;Icon&amp;gt;&lt;/code&gt; object. You still need to reduce the &lt;code&gt;Maybe&amp;lt;Icon&amp;gt;&lt;/code&gt; object to an &lt;code&gt;Icon&lt;/code&gt; object. You can do this with a Maybe helper method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;GetValueOrDefault(&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;@default)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;Aggregate(@default,&amp;nbsp;x&amp;nbsp;=&amp;gt;&amp;nbsp;x);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Given a &lt;code&gt;User&lt;/code&gt; object named &lt;code&gt;user&lt;/code&gt;, you can now use the composition and the &lt;code&gt;GetValueOrDefault&lt;/code&gt; method to get an &lt;code&gt;Icon&lt;/code&gt; object:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;icon&amp;nbsp;=&amp;nbsp;reader.ReadIcon(user).GetValueOrDefault(&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;.Default);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		First you use the composed &lt;code&gt;reader&lt;/code&gt; to produce a &lt;code&gt;Maybe&amp;lt;Icon&amp;gt;&lt;/code&gt; object, and then you use the &lt;code&gt;GetValueOrDefault&lt;/code&gt; method to reduce the &lt;code&gt;Maybe&amp;lt;Icon&amp;gt;&lt;/code&gt; object to an &lt;code&gt;Icon&lt;/code&gt; object.
	&lt;/p&gt;
	&lt;p&gt;
		The latter of these two steps, &lt;code&gt;GetValueOrDefault&lt;/code&gt;, is already based on the Maybe catamorphism, but the first step is still too implicit to clearly show the nature of what's actually going on. The next step is to refactor the Coalescing Composite to a list of monoidal values.
	&lt;/p&gt;
	&lt;h3 id=&quot;c75ce57c2b4f4315a93eaa91b653a370&quot;&gt;
		First &lt;a href=&quot;#c75ce57c2b4f4315a93eaa91b653a370&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		While not strictly necessary, you can introduce a &lt;code&gt;First&amp;lt;T&amp;gt;&lt;/code&gt; wrapper:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;sealed&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;class&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;First(&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;item)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(item&amp;nbsp;==&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;null&lt;/span&gt;)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;throw&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;ArgumentNullException&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;nameof&lt;/span&gt;(item));
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Item&amp;nbsp;=&amp;nbsp;item;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;Item&amp;nbsp;{&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;get&lt;/span&gt;;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;override&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;Equals(&lt;span style=&quot;color:blue;&quot;&gt;object&lt;/span&gt;&amp;nbsp;obj)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(!(obj&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;is&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;other))
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;false&lt;/span&gt;;
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;Equals(Item,&amp;nbsp;other.Item);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;override&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;GetHashCode()
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;Item.GetHashCode();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In this particular example, the &lt;code&gt;First&amp;lt;T&amp;gt;&lt;/code&gt; class adds no new capabilities, so it's technically redundant. You could add to it methods to combine two &lt;code&gt;First&amp;lt;T&amp;gt;&lt;/code&gt; objects into one (since &lt;em&gt;First&lt;/em&gt; forms a &lt;a href=&quot;/2017/11/27/semigroups&quot;&gt;semigroup&lt;/a&gt;), and perhaps a method or two to &lt;a href=&quot;/2017/12/11/semigroups-accumulate&quot;&gt;accumulate multiple values&lt;/a&gt;, but in this article, none of those are required.
	&lt;/p&gt;
	&lt;p&gt;
		While the class as shown above doesn't add any behaviour, I like that it signals intent, so I'll use it in that role.
	&lt;/p&gt;
	&lt;h3 id=&quot;c3feb40d90fc4d389fa0b3812abaa62c&quot;&gt;
		Lazy I/O in C# &lt;a href=&quot;#c3feb40d90fc4d389fa0b3812abaa62c&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Like in the above Haskell code, you'll need to be able to combine two &lt;code&gt;First&amp;lt;T&amp;gt;&lt;/code&gt; objects in a lazy fashion, in such a way that if the first object is populated, the I/O associated with producing the second value never happens. In Haskell I addressed that concern with a &lt;code&gt;newtype&lt;/code&gt; that, among other abstractions, is a monoid. You can do the same in C# with an extension method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;FindFirst&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;m,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;other)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(m.Value.IsPopulated())
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;m;
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;other;
}
 
&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;IsPopulated&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;m)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;m.Aggregate(&lt;span style=&quot;color:blue;&quot;&gt;false&lt;/span&gt;,&amp;nbsp;_&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;true&lt;/span&gt;);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;FindFirst&lt;/code&gt; method returns the first (leftmost) non-empty object of two options. It's a lazy version of the &lt;em&gt;First&lt;/em&gt; monoid, and &lt;a href=&quot;/2019/04/15/lazy-monoids&quot;&gt;that's still a monoid&lt;/a&gt;. It's truly lazy because it never accesses the &lt;code&gt;Value&lt;/code&gt; property on &lt;code&gt;other&lt;/code&gt;. While it has to force evaluation of the first lazy computation, &lt;code&gt;m&lt;/code&gt;, it doesn't have to evaluate &lt;code&gt;other&lt;/code&gt;. Thus, whenever &lt;code&gt;m&lt;/code&gt; is populated, &lt;code&gt;other&lt;/code&gt; can remain non-evaluated.
	&lt;/p&gt;
	&lt;p&gt;
		Since &lt;a href=&quot;/2017/11/20/monoids-accumulate&quot;&gt;monoids accumulate&lt;/a&gt;, you can also write an extension method to implement that functionality:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;FindFirst&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IEnumerable&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;source)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;identity&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;(()&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;());
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;source.Aggregate(identity,&amp;nbsp;(acc,&amp;nbsp;x)&amp;nbsp;=&amp;gt;&amp;nbsp;acc.FindFirst(x));
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This overload just uses the earlier &lt;code&gt;FindFirst&lt;/code&gt; extension method to fold an arbitrary number of lazy &lt;code&gt;First&amp;lt;T&amp;gt;&lt;/code&gt; objects into one. Notice that &lt;code&gt;Aggregate&lt;/code&gt; is the C# name for the list catamorphisms.
	&lt;/p&gt;
	&lt;p&gt;
		You can now compose the desired functionality using the basic building blocks of monoids, &lt;a href=&quot;/2018/03/22/functors&quot;&gt;functors&lt;/a&gt;, and catamorphisms.
	&lt;/p&gt;
	&lt;h3 id=&quot;0fe80a69c74c463dacb8af0f86898518&quot;&gt;
		Composition from universal abstractions &lt;a href=&quot;#0fe80a69c74c463dacb8af0f86898518&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The goal is still a function that takes a &lt;code&gt;User&lt;/code&gt; object as input and produces an &lt;code&gt;Icon&lt;/code&gt; object as output. While you could compose that functionality directly in-line where you need it, I think it may be helpful to package the composition in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Facade_pattern&quot;&gt;Facade&lt;/a&gt; object.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;class&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IconReaderFacade&lt;/span&gt;
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IReadOnlyCollection&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;&amp;gt;&amp;nbsp;readers;
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;IconReaderFacade(&lt;span style=&quot;color:#2b91af;&quot;&gt;IUserRepository&lt;/span&gt;&amp;nbsp;repository)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;readers&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IIconReader&lt;/span&gt;[]
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;GravatarReader&lt;/span&gt;(),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IdenticonReader&lt;/span&gt;(),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DBIconReader&lt;/span&gt;(repository)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;};
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;nbsp;ReadIcon(&lt;span style=&quot;color:#2b91af;&quot;&gt;User&lt;/span&gt;&amp;nbsp;user)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IEnumerable&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;lazyIcons&amp;nbsp;=&amp;nbsp;readers
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.Select(r&amp;nbsp;=&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;(()&amp;nbsp;=&amp;gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;r.ReadIcon(user).Select(i&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;(i))));
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Lazy&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;First&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;nbsp;m&amp;nbsp;=&amp;nbsp;lazyIcons.FindFirst();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;m.Value.Aggregate(&lt;span style=&quot;color:#2b91af;&quot;&gt;Icon&lt;/span&gt;.Default,&amp;nbsp;fi&amp;nbsp;=&amp;gt;&amp;nbsp;fi.Item);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		When you initialise an &lt;code&gt;IconReaderFacade&lt;/code&gt; object, it creates an array of the desired &lt;code&gt;readers&lt;/code&gt;. Whenever &lt;code&gt;ReadIcon&lt;/code&gt; is invoked, it first transforms all those readers to a sequence of potential icons. All the values in the sequence are lazily evaluated, so in this step, nothing actually happens, even though it looks as though all readers' &lt;code&gt;ReadIcon&lt;/code&gt; method gets called. The &lt;code&gt;Select&lt;/code&gt; method is a structure-preserving map, so all readers are still potential producers of &lt;code&gt;Icon&lt;/code&gt; objects.
	&lt;/p&gt;
	&lt;p&gt;
		You now have an &lt;code&gt;IEnumerable&amp;lt;Lazy&amp;lt;Maybe&amp;lt;First&amp;lt;Icon&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, which must be a good candidate for the prize for the &lt;em&gt;most nested generic .NET type of 2019&lt;/em&gt;. It fits, though, the input type for the above &lt;code&gt;FindFirst&lt;/code&gt; overload, so you can call that. The result is a single potential value &lt;code&gt;m&lt;/code&gt;. That's the list catamorphism applied.
	&lt;/p&gt;
	&lt;p&gt;
		Finally, you force evaluation of the lazy computation and apply the Maybe catamorphism (&lt;code&gt;Aggregate&lt;/code&gt;). The &lt;code&gt;@default&lt;/code&gt; value is &lt;code&gt;Icon.Default&lt;/code&gt;, which gets returned if &lt;code&gt;m&lt;/code&gt; turns out to be empty. When &lt;code&gt;m&lt;/code&gt; is populated, you pull the &lt;code&gt;Item&lt;/code&gt; out of the &lt;code&gt;First&lt;/code&gt; object. In either case, you now have an &lt;code&gt;Icon&lt;/code&gt; object to return.
	&lt;/p&gt;
	&lt;p&gt;
		This composition has exactly the same behaviour as the initial Chain of Responsibility implementation, but is now composed from universal abstractions.
	&lt;/p&gt;
	&lt;h3 id=&quot;23819ca370344b94875ddbf5bde5aef3&quot;&gt;
		Summary &lt;a href=&quot;#23819ca370344b94875ddbf5bde5aef3&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The Chain of Responsibility design pattern describes a flexible way to implement conditional logic. Instead of relying on keywords like &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;switch&lt;/code&gt;, you can compose the conditional logic from polymorphic objects. This gives you several advantages. One is that you get better separations of concerns, which will tend to make it easier to refactor the code. Another is that it's possible to change the behaviour at run time, by moving the objects around.
	&lt;/p&gt;
	&lt;p&gt;
		You can achieve a similar design, with equivalent advantages, by composing polymorphically similar functions in a list, map the functions to a list of potential values, and then use the list catamorphism to reduce many potential values to one. Finally, you apply the Maybe catamorphism to produce a value, even if the potential value is empty.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/07/22/chain-of-responsibility-as-catamorphisms</guid>
      </item>
    
      <item>
        <title>Tester-Doer isomorphisms</title>
        <link>https://blog.ploeh.dk/2019/07/15/tester-doer-isomorphisms/</link>
        <pubDate>Mon, 15 Jul 2019 07:35:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;The Tester-Doer pattern is equivalent to the Try-Parse idiom; both are equivalent to Maybe.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This article is part of &lt;a href=&quot;/2018/01/08/software-design-isomorphisms&quot;&gt;a series of articles about software design isomorphisms&lt;/a&gt;. An isomorphism is when a bi-directional lossless translation exists between two representations. Such translations exist between the &lt;em&gt;Tester-Doer&lt;/em&gt; pattern and the &lt;em&gt;Try-Parse&lt;/em&gt; idiom. Both can also be translated into operations that return &lt;a href=&quot;/2018/03/26/the-maybe-functor&quot;&gt;Maybe&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/tester-doer-try-parse-maybe-isomorphism.png&quot; alt=&quot;Isomorphisms between Tester-Doer, Try-Parse, and Maybe.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Given an implementation that uses one of those three idioms or abstractions, you can translate your design into one of the other options. This doesn't imply that each is of equal value. When it comes to composability, Maybe is superior to the two other alternatives, and Tester-Doer isn't thread-safe.
	&lt;/p&gt;
	&lt;h3 id=&quot;e95c8f5d7a6445139b58445d30498493&quot;&gt;
		Tester-Doer &lt;a href=&quot;#e95c8f5d7a6445139b58445d30498493&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The first time I explicitly encountered the Tester-Doer pattern was in the &lt;a href=&quot;https://amzn.to/2zXCCfH&quot;&gt;Framework Design Guidelines&lt;/a&gt;, which is from where I've taken the name. The pattern is, however, older. The idea that you can query an object about whether a given operation would be possible, and then you only perform it if the answer is affirmative, is almost a leitmotif in &lt;a href=&quot;http://amzn.to/1claOin&quot;&gt;Object-Oriented Software Construction&lt;/a&gt;. Bertrand Meyer often uses linked lists and stacks as examples, but I'll instead use the example that Krzysztof Cwalina and Brad Abrams use:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;ICollection&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;numbers&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:green;&quot;&gt;//&amp;nbsp;...&lt;/span&gt;
&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(!numbers.IsReadOnly)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;numbers.Add(1);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The idea with the Tester-Doer pattern is that you test whether an intended operation is legal, and only perform it if the answer is affirmative. In the example, you only add to the &lt;code&gt;numbers&lt;/code&gt; collection if &lt;code&gt;IsReadOnly&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Here, &lt;code&gt;IsReadOnly&lt;/code&gt; is the &lt;em&gt;Tester&lt;/em&gt;, and &lt;code&gt;Add&lt;/code&gt; is the &lt;em&gt;Doer&lt;/em&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		As Jeffrey Richter points out in the book, this is a dangerous pattern:
		&lt;blockquote&gt;
			&quot;The potential problem occurs when you have multiple threads accessing the object at the same time. For example, one thread could execute the test method, which reports that all is OK, and before the doer method executes, another thread could change the object, causing the doer to fail.&quot;
		&lt;/blockquote&gt;
		In other words, the pattern isn't thread-safe. While multi-threaded programming was always supported in .NET, this was less of a concern when the guidelines were first published (2006) than it is today. The guidelines were in internal use in Microsoft years before they were published, and there wasn't many multi-core processors in use back then.
	&lt;/p&gt;
	&lt;p&gt;
		Another problem with the Tester-Doer pattern is with discoverability. If you're looking for a way to add an element to a collection, you'd usually consider your search over once you find the &lt;code&gt;Add&lt;/code&gt; method. Even if you wonder &lt;em&gt;Is this operation safe? Can I always add an element to a collection?&lt;/em&gt; you &lt;em&gt;might&lt;/em&gt; consider looking for a &lt;code&gt;CanAdd&lt;/code&gt; method, but not an &lt;code&gt;IsReadOnly&lt;/code&gt; property. Most people don't even ask the question in the first place, though.
	&lt;/p&gt;
	&lt;h3 id=&quot;08bc9f42d8f048119f952aa9c2d94b34&quot;&gt;
		From Tester-Doer to Try-Parse &lt;a href=&quot;#08bc9f42d8f048119f952aa9c2d94b34&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You could refactor such a Tester-Doer API to a single method, which is both thread-safe and discoverable. One option is a variation of the Try-Parse idiom (discussed in detail below). Using it could look like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;ICollection&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;numbers&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:green;&quot;&gt;//&amp;nbsp;...&lt;/span&gt;
&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;wasAdded&amp;nbsp;=&amp;nbsp;numbers.TryAdd(1);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In this special case, you may not need the &lt;code&gt;wasAdded&lt;/code&gt; variable, because the original &lt;code&gt;Add&lt;/code&gt; operation never returned a value. If, on the other hand, you do care whether or not the element was added to the collection, you'd have to figure out what to do in the case where the return value is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, respectively.
	&lt;/p&gt;
	&lt;p&gt;
		Compared to the more idiomatic example of the Try-Parse idiom below, you may have noticed that the &lt;code&gt;TryAdd&lt;/code&gt; method shown here takes no &lt;code&gt;out&lt;/code&gt; parameter. This is because the original &lt;code&gt;Add&lt;/code&gt; method returns &lt;code&gt;void&lt;/code&gt;; there's nothing to return. From &lt;a href=&quot;/2018/01/15/unit-isomorphisms&quot;&gt;unit isomorphisms&lt;/a&gt;, however, we know that &lt;em&gt;unit&lt;/em&gt; is isomorphic to &lt;code&gt;void&lt;/code&gt;, so we could, more explicitly, have defined a &lt;code&gt;TryAdd&lt;/code&gt; method with this signature:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;TryAdd(&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;item,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;out&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;&amp;nbsp;unit)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		There's no point in doing this, however, apart from demonstrating that the isomorphism holds.
	&lt;/p&gt;
	&lt;h3 id=&quot;e246bcfabcab42e8b76e2b3e314174c4&quot;&gt;
		From Tester-Doer to Maybe &lt;a href=&quot;#e246bcfabcab42e8b76e2b3e314174c4&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can also refactor the add-to-collection example to return a Maybe value, although in this degenerate case, it makes little sense. If you automate the refactoring process, you'd arrive at an API like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;&amp;gt;&amp;nbsp;TryAdd(&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;item)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Using it would look like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;ICollection&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;numbers&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:green;&quot;&gt;//&amp;nbsp;...&lt;/span&gt;
&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;&amp;gt;&amp;nbsp;m&amp;nbsp;=&amp;nbsp;numbers.TryAdd(1);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The contract is consistent with what Maybe implies: You'd get an empty &lt;code&gt;Maybe&amp;lt;Unit&amp;gt;&lt;/code&gt; object if the &lt;em&gt;add&lt;/em&gt; operation 'failed', and a populated &lt;code&gt;Maybe&amp;lt;Unit&amp;gt;&lt;/code&gt; object if the &lt;em&gt;add&lt;/em&gt; operation succeeded. Even in the populated case, though, the value contained in the Maybe object would be &lt;em&gt;unit&lt;/em&gt;, which carries no further information than its existence.
	&lt;/p&gt;
	&lt;p&gt;
		To be clear, this isn't close to a proper functional design because all the interesting action happens as a side effect. Does the design have to be functional? No, it clearly isn't in this case, but Maybe is a concept that originated in functional programming, so you could be misled to believe that I'm trying to pass this particular design off as functional. It's not.
	&lt;/p&gt;
	&lt;p&gt;
		A functional version of this API could look like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;ICollection&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;&amp;nbsp;TryAdd(&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;item)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		An implementation wouldn't mutate the object itself, but rather return a new collection with the added item, in case that was possible. This is, however, always possible, because you can always concatenate &lt;code&gt;item&lt;/code&gt; to the front of the collection. In other words, this particular line of inquiry is increasingly veering into the territory of the absurd. This isn't, however, a counter-example of my proposition that the isomorphism exists; it's just a result of the initial example being degenerate.
	&lt;/p&gt;
	&lt;h3 id=&quot;9817f0d35d99428f93c38cab9fabc9ad&quot;&gt;
		Try-Parse &lt;a href=&quot;#9817f0d35d99428f93c38cab9fabc9ad&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Another idiom described in the Framework Design Guidelines is the Try-Parse idiom. This seems to be a coding idiom more specific to the .NET framework, which is the reason I call it an &lt;em&gt;idiom&lt;/em&gt; instead of a &lt;em&gt;pattern&lt;/em&gt;. (Perhaps it is, after all, a pattern... I'm sure many of my readers are better informed about how problems like these are solved in other languages, and can enlighten me.)
	&lt;/p&gt;
	&lt;p&gt;
		A better name might be &lt;em&gt;Try-Do&lt;/em&gt;, since the idiom doesn't have to be constrained to parsing. The example that Cwalina and Abrams supply, however, relates to parsing a &lt;code&gt;string&lt;/code&gt; into a &lt;code&gt;DateTime&lt;/code&gt; value. Such an API is &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.datetime.tryparse&quot;&gt;already available in the base class library&lt;/a&gt;. Using it looks like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;couldParse&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTime&lt;/span&gt;.TryParse(candidate,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;out&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTime&lt;/span&gt;&amp;nbsp;dateTime);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Since &lt;code&gt;DateTime&lt;/code&gt; is a &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types&quot;&gt;value type&lt;/a&gt;, the &lt;code&gt;out&lt;/code&gt; parameter will never be &lt;code&gt;null&lt;/code&gt;, even if parsing fails. You can, however, examine the return value &lt;code&gt;couldParse&lt;/code&gt; to determine whether the &lt;code&gt;candidate&lt;/code&gt; could be parsed.
	&lt;/p&gt;
	&lt;p&gt;
		In the running commentary in the book, Jeffrey Richter likes this much better:
		&lt;blockquote&gt;
			&quot;I like this guideline a lot. It solves the race-condition problem and the performance problem.&quot;
		&lt;/blockquote&gt;
		I agree that it's better than Tester-Doer, but that doesn't mean that you can't refactor such a design to that pattern.
	&lt;/p&gt;
	&lt;h3 id=&quot;166ef01b6b64481a85fe64a6e9e07dc6&quot;&gt;
		From Try-Parse to Tester-Doer &lt;a href=&quot;#166ef01b6b64481a85fe64a6e9e07dc6&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		While I see no compelling reason to design parsing attempts with the Tester-Doer pattern, it's possible. You could create an API that enables interaction like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTime&lt;/span&gt;&amp;nbsp;dateTime&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;default&lt;/span&gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTime&lt;/span&gt;);
&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;canParse&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTimeEnvy&lt;/span&gt;.CanParse(candidate);
&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(canParse)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dateTime&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTime&lt;/span&gt;.Parse(candidate);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You'd need to add a new &lt;code&gt;CanParse&lt;/code&gt; method with this signature:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;CanParse(&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;candidate)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In this particular example, you don't have to add a &lt;code&gt;Parse&lt;/code&gt; method, because it already exists in the base class library, but in other examples, you'd have to add such a method as well.
	&lt;/p&gt;
	&lt;p&gt;
		This example doesn't suffer from issues with thread safety, since strings are immutable, but in general, that problem is always a concern with the Tester-Doer &lt;a href=&quot;/2019/01/21/some-thoughts-on-anti-patterns&quot;&gt;anti-pattern&lt;/a&gt;. Discoverability still suffers in this example.
	&lt;/p&gt;
	&lt;h3 id=&quot;ffd6284cfc8f4f528d1a3b80849fbf8c&quot;&gt;
		From Try-Parse to Maybe &lt;a href=&quot;#ffd6284cfc8f4f528d1a3b80849fbf8c&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		While the Try-Parse idiom is thread-safe, it isn't composable. Every time you run into an API modelled over this template, you have to stop what you're doing and check the return value. Did the operation succeed? Was should the code do if it didn't?
	&lt;/p&gt;
	&lt;p&gt;
		&lt;em&gt;Maybe&lt;/em&gt;, on the other hand, is composable, so is a much better way to model problems such as parsing. Typically, methods or functions that return Maybe values are still prefixed with &lt;em&gt;Try&lt;/em&gt;, but there's no longer any &lt;code&gt;out&lt;/code&gt; parameter. A Maybe-based &lt;code&gt;TryParse&lt;/code&gt; function could look like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTime&lt;/span&gt;&amp;gt;&amp;nbsp;TryParse(&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;candidate)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You could use it like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTime&lt;/span&gt;&amp;gt;&amp;nbsp;m&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTimeEnvy&lt;/span&gt;.TryParse(candidate);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		If the &lt;code&gt;candidate&lt;/code&gt; was successfully parsed, you get a populated &lt;code&gt;Maybe&amp;lt;DateTime&amp;gt;&lt;/code&gt;; if the string was invalid, you get an empty &lt;code&gt;Maybe&amp;lt;DateTime&amp;gt;&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		A Maybe object composes much better with other computations. Contrary to the Try-Parse idiom, you don't have to stop and examine a Boolean return value. You don't even have to deal with empty cases at the point where you parse. Instead, you can defer the decision about what to do in case of failure until a later time, where it may be more obvious what to do in that case.
	&lt;/p&gt;
	&lt;h3 id=&quot;4f27ce3476114a5f9b0f80fd415e5370&quot;&gt;
		Maybe &lt;a href=&quot;#4f27ce3476114a5f9b0f80fd415e5370&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		In my &lt;a href=&quot;https://blog.ploeh.dk/encapsulation-and-solid&quot;&gt;Encapsulation and SOLID&lt;/a&gt; Pluralsight course, you get a walk-through of all three options for dealing with an operation that could potentially fail. Like in this article, the course starts with Tester-Doer, progresses over Try-Parse, and arrives at a Maybe-based implementation. In that course, the example involves reading a (previously stored) message from a text file. The final API looks like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;nbsp;Read(&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;id)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The protocol implied by such a signature is that you supply an ID, and if a message with that ID exists on disc, you receive a populated &lt;code&gt;Maybe&amp;lt;string&amp;gt;&lt;/code&gt;; otherwise, an empty object. This is not only composable, but also thread-safe. For anyone who understands the &lt;a href=&quot;/2017/10/04/from-design-patterns-to-category-theory&quot;&gt;universal abstraction&lt;/a&gt; of Maybe, it's clear that this is an operation that could fail. Ultimately, client code will have to deal with empty Maybe values, but this doesn't have to happen immediately. Such a decision can be deferred until a proper context exists for that purpose.
	&lt;/p&gt;
	&lt;h3 id=&quot;d35fbacb32bb4ef6afc843813ba901f1&quot;&gt;
		From Maybe to Tester-Doer &lt;a href=&quot;#d35fbacb32bb4ef6afc843813ba901f1&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Since Tester-Doer is the least useful of the patterns discussed in this article, it makes little sense to refactor a Maybe-based API to a Tester-Doer implementation. Nonetheless, it's still possible. The API could look like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;Exists(&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;id)

&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;Read(&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;id)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Not only is this design not thread-safe, but it's another example of poor discoverability. While the doer is called &lt;code&gt;Read&lt;/code&gt;, the tester isn't called &lt;code&gt;CanRead&lt;/code&gt;, but rather &lt;code&gt;Exists&lt;/code&gt;. If the class has other members, these could be listed interleaved between &lt;code&gt;Exists&lt;/code&gt; and &lt;code&gt;Read&lt;/code&gt;. It wouldn't be obvious that these two members were designed to be used together.
	&lt;/p&gt;
	&lt;p&gt;
		Again, the intended usage is code like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;message;
&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(fileStore.Exists(49))
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;message&amp;nbsp;=&amp;nbsp;fileStore.Read(49);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This is still problematic, because you need to decide what to do in the &lt;code&gt;else&lt;/code&gt; case as well, although you don't see that case here.
	&lt;/p&gt;
	&lt;p&gt;
		The point is, still, that you &lt;em&gt;can&lt;/em&gt; translate from one representation to another without loss of information; not that you should.
	&lt;/p&gt;
	&lt;h3 id=&quot;3bbc92082af143d29681b2ce0bb11ccb&quot;&gt;
		From Maybe to Try-Parse &lt;a href=&quot;#3bbc92082af143d29681b2ce0bb11ccb&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Of the three representations discussed in this article, I firmly believe that a Maybe-based API is superior. Unfortunately, the .NET base class library doesn't (yet) come with a built-in Maybe object, so if you're developing an API as part of a reusable library, you have two options:
		&lt;ul&gt;
			&lt;li&gt;Export the library's &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt; type together with the methods that return it.&lt;/li&gt;
			&lt;li&gt;Use Try-Parse for interoperability reasons.&lt;/li&gt;
		&lt;/ul&gt;
		This is the only reason I can think of to use the Try-Parse idiom. For the &lt;code&gt;FileStore&lt;/code&gt; example from my Pluralsight course, this would imply not a &lt;code&gt;TryParse&lt;/code&gt; method, but a &lt;code&gt;TryRead&lt;/code&gt; method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;bool&lt;/span&gt;&amp;nbsp;TryRead(&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;id,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;out&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;message)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This would enable you to expose the method in a reusable library. Client code could interact with it like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;nbsp;message;
&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(!fileStore.TryRead(50,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;out&lt;/span&gt;&amp;nbsp;message))
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;message&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This has all the problems associated with the Try-Parse idiom already discussed in this article, but it does, at least, have a basic use case.
	&lt;/p&gt;
	&lt;h3 id=&quot;c04073bcc534481eaaf1ba43dd2a22a4&quot;&gt;
		Isomorphism with Either &lt;a href=&quot;#c04073bcc534481eaaf1ba43dd2a22a4&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		At this point, I hope that you find it reasonable to believe that the three representations, Tester-Doer, Try-Parse, and Maybe, are isomorphic. You can translate between any of these representations to any other of these without loss of information. This also means that you can translate back again.
	&lt;/p&gt;
	&lt;p&gt;
		While I've only argued with a series of examples, it's my experience that these three representations are truly isomorphic. You can always translate any of these representations into another. Mostly, though, I translate into Maybe. If you disagree with my proposition, all you have to do is to provide a counter-example.
	&lt;/p&gt;
	&lt;p&gt;
		There's a fourth isomorphism that's already well-known, and that's between Maybe and &lt;a href=&quot;/2018/06/11/church-encoded-either&quot;&gt;Either&lt;/a&gt;. Specifically, &lt;code&gt;Maybe&amp;lt;T&amp;gt;&lt;/code&gt; is isomorphic to &lt;code&gt;Either&amp;lt;Unit, T&amp;gt;&lt;/code&gt;. In &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;, this is easily demonstrated with this set of functions:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;toMaybe&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Either&lt;/span&gt;&amp;nbsp;()&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;a
toMaybe&amp;nbsp;(Left&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;()&lt;/span&gt;)&amp;nbsp;=&amp;nbsp;Nothing
toMaybe&amp;nbsp;(Right&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;Just&amp;nbsp;x
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;fromMaybe&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Either&lt;/span&gt;&amp;nbsp;()&amp;nbsp;a
fromMaybe&amp;nbsp;Nothing&amp;nbsp;=&amp;nbsp;Left&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;()&lt;/span&gt;
fromMaybe&amp;nbsp;(Just&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;Right&amp;nbsp;x&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Translated to C#, using the &lt;a href=&quot;/2018/06/04/church-encoded-maybe&quot;&gt;Church-encoded Maybe&lt;/a&gt; together with the Church-encoded Either, these two functions could look like the following, starting with the conversion from Maybe to Either:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:green;&quot;&gt;//&amp;nbsp;On&amp;nbsp;Maybe:&lt;/span&gt;
&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IEither&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;ToEither&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IMaybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;source)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;source.Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;IEither&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nothing:&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Left&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;.Value),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;just:&amp;nbsp;x&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Right&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(x));
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Likewise, the conversion from Either to Maybe:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:green;&quot;&gt;//&amp;nbsp;On&amp;nbsp;Either:&lt;/span&gt;
&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IMaybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;ToMaybe&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IEither&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;source)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;source.Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;IMaybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;onLeft:&amp;nbsp;_&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Nothing&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;onRight:&amp;nbsp;x&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Just&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(x));
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can convert back and forth to your heart's content, as this parametrised &lt;a href=&quot;https://xunit.github.io&quot;&gt;xUnit.net&lt;/a&gt; 2.3.1 test shows:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;[&lt;span style=&quot;color:#2b91af;&quot;&gt;Theory&lt;/span&gt;]
[&lt;span style=&quot;color:#2b91af;&quot;&gt;InlineData&lt;/span&gt;(42)]
[&lt;span style=&quot;color:#2b91af;&quot;&gt;InlineData&lt;/span&gt;(1337)]
[&lt;span style=&quot;color:#2b91af;&quot;&gt;InlineData&lt;/span&gt;(2112)]
[&lt;span style=&quot;color:#2b91af;&quot;&gt;InlineData&lt;/span&gt;(90125)]
&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;void&lt;/span&gt;&amp;nbsp;IsomorphicWithPopulatedMaybe(&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;i)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;expected&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Right&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Unit&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;(i);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;actual&amp;nbsp;=&amp;nbsp;expected.ToMaybe().ToEither();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Assert&lt;/span&gt;.Equal(expected,&amp;nbsp;actual);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I decided to exclude &lt;code&gt;IEither&amp;lt;Unit, T&amp;gt;&lt;/code&gt; from the overall theme of this article in order to better contrast three alternatives that may not otherwise look equivalent. That &lt;code&gt;IEither&amp;lt;Unit, T&amp;gt;&lt;/code&gt; is isomorphic to &lt;code&gt;IMaybe&amp;lt;T&amp;gt;&lt;/code&gt; is a well-known result. Besides, I think that both of these two representations already inhabit the same conceptual space. Either and Maybe are both well-known in statically typed functional programming.
	&lt;/p&gt;
	&lt;h3 id=&quot;8e3e7b55ac1e49568712675713426e59&quot;&gt;
		Summary &lt;a href=&quot;#8e3e7b55ac1e49568712675713426e59&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The Tester-Doer pattern is a decades-old design pattern that attempts to model how to perform operations that can potentially fail, without relying on exceptions for flow control. It predates mainstream multi-core processors by decades, which can explain why it even exists as a pattern in the first place. At the time people arrived at the pattern, thread-safety wasn't a big concern.
	&lt;/p&gt;
	&lt;p&gt;
		The Try-Parse idiom is a thread-safe alternative to the Tester-Doer pattern. It combines the two &lt;em&gt;tester&lt;/em&gt; and &lt;em&gt;doer&lt;/em&gt; methods into a single method with an &lt;code&gt;out&lt;/code&gt; parameter. While thread-safe, it's not composable.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;em&gt;Maybe&lt;/em&gt; offers the best of both worlds. It's both thread-safe and composable. It's also as discoverable as any Try-Parse method.
	&lt;/p&gt;
	&lt;p&gt;
		These three alternatives are all, however, isomorphic. This means that you can refactor any of the three designs into one of the other designs, without loss of information. It also means that you can implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapters&lt;/a&gt; between particular implementations, should you so desire. You see this frequently in &lt;a href=&quot;https://fsharp.org&quot;&gt;F#&lt;/a&gt; code, where functions that return &lt;code&gt;'a option&lt;/code&gt; adapt Try-Parse methods from the .NET base class library.
	&lt;/p&gt;
	&lt;p&gt;
		While all three designs are equivalent in the sense that you can translate one into another, it doesn't imply that they're equally useful. &lt;em&gt;Maybe&lt;/em&gt; is the superior design, and Tester-Doer clearly inferior.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;strong&gt;Next:&lt;/strong&gt; &lt;a href=&quot;/2018/05/22/church-encoding&quot;&gt;Church encoding&lt;/a&gt;.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/07/15/tester-doer-isomorphisms</guid>
      </item>
    
      <item>
        <title>Payment types catamorphism</title>
        <link>https://blog.ploeh.dk/2019/07/08/payment-types-catamorphism/</link>
        <pubDate>Mon, 08 Jul 2019 06:08:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;You can find the catamorphism for a custom sum type. Here's an example.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This article is part of an &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;article series about catamorphisms&lt;/a&gt;. A catamorphism is a &lt;a href=&quot;/2017/10/04/from-design-patterns-to-category-theory&quot;&gt;universal abstraction&lt;/a&gt; that describes how to digest a data structure into a potentially more compact value.
	&lt;/p&gt;
	&lt;p&gt;
		This article presents the catamorphism for a domain-specific &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;sum type&lt;/a&gt;, as well as how to identify it. The beginning of this article presents the catamorphism in C#, with a few examples. The rest of the article describes how to deduce the catamorphism. This part of the article presents my work in &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;. Readers not comfortable with Haskell can just read the first part, and consider the rest of the article as an optional appendix.
	&lt;/p&gt;
	&lt;p&gt;
		In all previous articles in the series, you've seen catamorphisms for well-known data structures: &lt;a href=&quot;/2019/05/06/boolean-catamorphism&quot;&gt;Boolean values&lt;/a&gt;, &lt;a href=&quot;/2019/05/13/peano-catamorphism&quot;&gt;Peano numbers&lt;/a&gt;, &lt;a href=&quot;/2019/05/20/maybe-catamorphism&quot;&gt;Maybe&lt;/a&gt;, &lt;a href=&quot;/2019/06/10/tree-catamorphism&quot;&gt;trees&lt;/a&gt;, and so on. These are all general-purpose data structures, so you might be left with the impression that catamorphisms are only related to such general types. That's not the case. The point of this article is to demonstrate that you can find the catamorphism for your own custom, domain-specific sum type as well.
	&lt;/p&gt;
	&lt;h3 id=&quot;2b6f7df594c0474589ae9805f1e1a1d0&quot;&gt;
		C# catamorphism &lt;a href=&quot;#2b6f7df594c0474589ae9805f1e1a1d0&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The custom type we'll examine in this article is the &lt;a href=&quot;/2018/06/18/church-encoded-payment-types&quot;&gt;Church-encoded payment types&lt;/a&gt; I've previously written about. It's just an example of a custom data type, but it serves the purpose of illustration because I've already shown it as a Church encoding in C#, &lt;a href=&quot;/2018/06/25/visitor-as-a-sum-type&quot;&gt;as a Visitor in C#&lt;/a&gt;, and &lt;a href=&quot;/2016/11/28/easy-domain-modelling-with-types&quot;&gt;as a discriminated union in F#&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		The catamorphism for the &lt;code&gt;IPaymentType&lt;/code&gt; interface is the &lt;code&gt;Match&lt;/code&gt; method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;PaymentService&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;individual,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;PaymentService&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;parent,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;ChildPaymentService&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;child);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		As has turned out to be a common trait, the catamorphism is identical to the Church encoding.
	&lt;/p&gt;
	&lt;p&gt;
		I'm not going to show more than a few examples of using the &lt;code&gt;Match&lt;/code&gt; method, because you can find other examples in the previous articles, 
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IPaymentType&lt;/span&gt;&amp;nbsp;p&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Individual&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;PaymentService&lt;/span&gt;(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Visa&amp;quot;&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Pay&amp;quot;&lt;/span&gt;));
&amp;gt; p.Match(ps&amp;nbsp;=&amp;gt;&amp;nbsp;ps.Name,&amp;nbsp;ps&amp;nbsp;=&amp;gt;&amp;nbsp;ps.Name,&amp;nbsp;cps&amp;nbsp;=&amp;gt;&amp;nbsp;cps.PaymentService.Name)
&quot;Visa&quot;
&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IPaymentType&lt;/span&gt;&amp;nbsp;p&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Parent&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;PaymentService&lt;/span&gt;(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Visa&amp;quot;&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Pay&amp;quot;&lt;/span&gt;));
&amp;gt; p.Match(ps&amp;nbsp;=&amp;gt;&amp;nbsp;ps.Name,&amp;nbsp;ps&amp;nbsp;=&amp;gt;&amp;nbsp;ps.Name,&amp;nbsp;cps&amp;nbsp;=&amp;gt;&amp;nbsp;cps.PaymentService.Name)
&quot;Visa&quot;
&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IPaymentType&lt;/span&gt;&amp;nbsp;p&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Child&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;ChildPaymentService&lt;/span&gt;(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;1234&amp;quot;&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;PaymentService&lt;/span&gt;(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Visa&amp;quot;&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Pay&amp;quot;&lt;/span&gt;)));
&amp;gt; p.Match(ps&amp;nbsp;=&amp;gt;&amp;nbsp;ps.Name,&amp;nbsp;ps&amp;nbsp;=&amp;gt;&amp;nbsp;ps.Name,&amp;nbsp;cps&amp;nbsp;=&amp;gt;&amp;nbsp;cps.PaymentService.Name)
&quot;Visa&quot;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		These three examples from a &lt;em&gt;C# Interactive&lt;/em&gt; session demonstrate that no matter which payment method you use, you can use the same &lt;code&gt;Match&lt;/code&gt; method call to extract the payment name from the &lt;code&gt;p&lt;/code&gt; object.
	&lt;/p&gt;
	&lt;h3 id=&quot;f2334a900eef421cb24c6e48a96e411b&quot;&gt;
		Payment types F-Algebra &lt;a href=&quot;#f2334a900eef421cb24c6e48a96e411b&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As in the &lt;a href=&quot;/2019/06/24/full-binary-tree-catamorphism&quot;&gt;previous article&lt;/a&gt;, I'll use &lt;code&gt;Fix&lt;/code&gt; and &lt;code&gt;cata&lt;/code&gt; as explained in &lt;a href=&quot;https://bartoszmilewski.com&quot;&gt;Bartosz Milewski&lt;/a&gt;'s excellent &lt;a href=&quot;https://bartoszmilewski.com/2017/02/28/f-algebras/&quot;&gt;article on F-Algebras&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		First, you'll have to define the auxiliary types involved in this API:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;PaymentService&amp;nbsp;=&amp;nbsp;PaymentService&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;paymentServiceName&amp;nbsp;::&amp;nbsp;String
&amp;nbsp;&amp;nbsp;,&amp;nbsp;paymentServiceAction&amp;nbsp;::&amp;nbsp;String
&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)
 
&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;ChildPaymentService&amp;nbsp;=&amp;nbsp;ChildPaymentService&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;originalTransactionKey&amp;nbsp;::&amp;nbsp;String
&amp;nbsp;&amp;nbsp;,&amp;nbsp;parentPaymentService&amp;nbsp;::&amp;nbsp;PaymentService
&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While F-Algebras and fixed points are mostly used for recursive data structures, you can also define an F-Algebra for a non-recursive data structure. You already saw examples of that in the articles about &lt;a href=&quot;/2019/05/06/boolean-catamorphism&quot;&gt;Boolean catamorphism&lt;/a&gt;, &lt;a href=&quot;/2019/05/20/maybe-catamorphism&quot;&gt;Maybe catamorphism&lt;/a&gt;, and &lt;a href=&quot;/2019/06/03/either-catamorphism&quot;&gt;Either catamorphism&lt;/a&gt;. While each of the three payment types have associated data, none of it is parametrically polymorphic, so a single type argument for the carrier type suffices:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;PaymentTypeF&amp;nbsp;c&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IndividualF&amp;nbsp;PaymentService
&amp;nbsp;&amp;nbsp;|&amp;nbsp;ParentF&amp;nbsp;PaymentService
&amp;nbsp;&amp;nbsp;|&amp;nbsp;ChildF&amp;nbsp;ChildPaymentService
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentTypeF&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;(IndividualF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;IndividualF&amp;nbsp;ps
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ParentF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;ParentF&amp;nbsp;ps
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ChildF&amp;nbsp;cps)&amp;nbsp;=&amp;nbsp;ChildF&amp;nbsp;cps&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I chose to call the carrier type &lt;code&gt;c&lt;/code&gt; (for &lt;em&gt;carrier&lt;/em&gt;). As was also the case with &lt;code&gt;BoolF&lt;/code&gt;, &lt;code&gt;MaybeF&lt;/code&gt;, and &lt;code&gt;EitherF&lt;/code&gt;, the &lt;code&gt;Functor&lt;/code&gt; instance ignores the map function because the carrier type is missing from all three cases. Like the &lt;code&gt;Functor&lt;/code&gt; instances for &lt;code&gt;BoolF&lt;/code&gt;, &lt;code&gt;MaybeF&lt;/code&gt;, and &lt;code&gt;EitherF&lt;/code&gt;, it'd seem that nothing happens, but at the type level, this is still a translation from &lt;code&gt;PaymentTypeF c&lt;/code&gt; to &lt;code&gt;PaymentTypeF c1&lt;/code&gt;. Not much of a function, perhaps, but definitely an &lt;em&gt;endofunctor&lt;/em&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		Some helper functions make it a little easier to create &lt;code&gt;Fix PaymentTypeF&lt;/code&gt; values, but there's really not much to them:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;individualF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentService&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Fix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentTypeF&lt;/span&gt;
individualF&amp;nbsp;=&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;IndividualF
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;parentF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentService&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Fix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentTypeF&lt;/span&gt;
parentF&amp;nbsp;=&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;ParentF
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;childF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ChildPaymentService&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Fix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentTypeF&lt;/span&gt;
childF&amp;nbsp;=&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;ChildF&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		That's all you need to identify the catamorphism.
	&lt;/p&gt;
	&lt;h3 id=&quot;da3c2c0fee2747bebb1db38c15110bcb&quot;&gt;
		Haskell catamorphism &lt;a href=&quot;#da3c2c0fee2747bebb1db38c15110bcb&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		At this point, you have two out of three elements of an F-Algebra. You have an endofunctor (&lt;code&gt;PaymentTypeF&lt;/code&gt;), and an object &lt;code&gt;c&lt;/code&gt;, but you still need to find a morphism &lt;code&gt;PaymentTypeF c -&amp;gt; c&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		As in the previous articles, start by writing a function that will become the catamorphism, based on &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;paymentF&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;(IndividualF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ParentF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ChildF&amp;nbsp;cps)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While this compiles, with its &lt;code&gt;undefined&lt;/code&gt; implementations, it obviously doesn't do anything useful. I find, however, that it helps me think. How can you return a value of the type &lt;code&gt;c&lt;/code&gt; from the &lt;code&gt;IndividualF&lt;/code&gt; case? You could pass an argument to the &lt;code&gt;paymentF&lt;/code&gt; function, but you shouldn't ignore the data &lt;code&gt;ps&lt;/code&gt; contained in the case, so it has to be a function:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;paymentF&amp;nbsp;fi&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;(IndividualF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;fi&amp;nbsp;ps
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ParentF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ChildF&amp;nbsp;cps)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I chose to call the argument &lt;code&gt;fi&lt;/code&gt;, for &lt;em&gt;function, individual&lt;/em&gt;. You can pass a similar argument to deal with the &lt;code&gt;ParentF&lt;/code&gt; case:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;paymentF&amp;nbsp;fi&amp;nbsp;fp&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;(IndividualF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;fi&amp;nbsp;ps
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ParentF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;fp&amp;nbsp;ps
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ChildF&amp;nbsp;cps)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		And of course with the remaining &lt;code&gt;ChildF&lt;/code&gt; case as well:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;paymentF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;PaymentService&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;PaymentService&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;ChildPaymentService&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Fix&amp;nbsp;PaymentTypeF&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
paymentF&amp;nbsp;fi&amp;nbsp;fp&amp;nbsp;fc&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;(IndividualF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;fi&amp;nbsp;ps
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ParentF&amp;nbsp;ps)&amp;nbsp;=&amp;nbsp;fp&amp;nbsp;ps
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(ChildF&amp;nbsp;cps)&amp;nbsp;=&amp;nbsp;fc&amp;nbsp;cps&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This works. Since &lt;code&gt;cata&lt;/code&gt; has the type &lt;code&gt;Functor f =&amp;gt; (f a -&amp;gt; a) -&amp;gt; Fix f -&amp;gt; a&lt;/code&gt;, that means that &lt;code&gt;alg&lt;/code&gt; has the type &lt;code&gt;f a -&amp;gt; a&lt;/code&gt;. In the case of &lt;code&gt;PaymentTypeF&lt;/code&gt;, the compiler infers that the &lt;code&gt;alg&lt;/code&gt; function has the type &lt;code&gt;PaymentTypeF c -&amp;gt; c&lt;/code&gt;, which is just what you need!
	&lt;/p&gt;
	&lt;p&gt;
		You can now see what the carrier type &lt;code&gt;c&lt;/code&gt; is for. It's the type that the algebra extracts, and thus the type that the catamorphism returns.
	&lt;/p&gt;
	&lt;p&gt;
		This, then, is the catamorphism for the payment types. Except for the &lt;a href=&quot;/2019/06/10/tree-catamorphism&quot;&gt;tree catamorphism&lt;/a&gt;, all catamorphisms so far have been pairs, but this one is a triplet of functions. This is because the sum type has three cases instead of two.
	&lt;/p&gt;
	&lt;p&gt;
		As you've seen repeatedly, this isn't the only possible catamorphism, since you can, for example, trivially reorder the arguments to &lt;code&gt;paymentF&lt;/code&gt;. The version shown here is, however, equivalent to the above C# &lt;code&gt;Match&lt;/code&gt; method.
	&lt;/p&gt;
	&lt;h3 id=&quot;e6248a9ea34148c79c2b03acc92de5f7&quot;&gt;
		Usage &lt;a href=&quot;#e6248a9ea34148c79c2b03acc92de5f7&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can use the catamorphism as a basis for other functionality. If, for example, you want to convert a &lt;code&gt;Fix PaymentTypeF&lt;/code&gt; value to JSON, you can first define an &lt;a href=&quot;http://hackage.haskell.org/package/aeson/docs/Data-Aeson.html&quot;&gt;Aeson&lt;/a&gt; record type for that purpose:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;PaymentJson&amp;nbsp;=&amp;nbsp;PaymentJson&amp;nbsp;{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;name&amp;nbsp;::&amp;nbsp;String
&amp;nbsp;&amp;nbsp;,&amp;nbsp;action&amp;nbsp;::&amp;nbsp;String
&amp;nbsp;&amp;nbsp;,&amp;nbsp;startRecurrent&amp;nbsp;::&amp;nbsp;Bool
&amp;nbsp;&amp;nbsp;,&amp;nbsp;transactionKey&amp;nbsp;::&amp;nbsp;Maybe&amp;nbsp;String
&amp;nbsp;&amp;nbsp;}&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Generic&lt;/span&gt;)
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ToJSON&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentJson&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Subsequently, you can use &lt;code&gt;paymentF&lt;/code&gt; to implement a conversion from &lt;code&gt;Fix PaymentTypeF&lt;/code&gt; to &lt;code&gt;PaymentJson&lt;/code&gt;, as in the previous articles:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;toJson&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Fix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentTypeF&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;PaymentJson&lt;/span&gt;
toJson&amp;nbsp;=
&amp;nbsp;&amp;nbsp;paymentF
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(\(PaymentService&amp;nbsp;n&amp;nbsp;a)&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;gt;&amp;nbsp;PaymentJson&amp;nbsp;n&amp;nbsp;a&amp;nbsp;False&amp;nbsp;Nothing)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(\(PaymentService&amp;nbsp;n&amp;nbsp;a)&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;-&amp;gt;&amp;nbsp;PaymentJson&amp;nbsp;n&amp;nbsp;a&amp;nbsp;True&amp;nbsp;Nothing)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(\(ChildPaymentService&amp;nbsp;k&amp;nbsp;(PaymentService&amp;nbsp;n&amp;nbsp;a))&amp;nbsp;-&amp;gt;&amp;nbsp;PaymentJson&amp;nbsp;n&amp;nbsp;a&amp;nbsp;False&amp;nbsp;$&amp;nbsp;Just&amp;nbsp;k)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Testing it in GHCi, it works as it's supposed to:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Data.Aeson B Payment&amp;gt; B.putStrLn $ encode $ toJson $ parentF $ PaymentService &quot;Visa&quot; &quot;Pay&quot;
{&quot;transactionKey&quot;:null,&quot;startRecurrent&quot;:true,&quot;action&quot;:&quot;Pay&quot;,&quot;name&quot;:&quot;Visa&quot;}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Clearly, it would have been easier to define the payment types shown here as a regular Haskell sum type and just use standard pattern matching, but the purpose of this article isn't to present useful code; the only purpose of the code here is to demonstrate how to identify the catamorphism for a custom domain-specific sum type.
	&lt;/p&gt;
	&lt;h3 id=&quot;153479fffaf647f6ad6f5fc6a63fe025&quot;&gt;
		Summary &lt;a href=&quot;#153479fffaf647f6ad6f5fc6a63fe025&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Even custom, domain-specific sum types have catamorphisms. This article presented the catamorphism for a custom payment sum type. Because this particular sum type has three cases, the catamorphism is a triplet, instead of a pair, which has otherwise been the most common shape of catamorphisms in previous articles.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;strong&gt;Next:&lt;/strong&gt; &lt;a href=&quot;/2018/03/05/some-design-patterns-as-universal-abstractions&quot;&gt;Some design patterns as universal abstractions&lt;/a&gt;.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/07/08/payment-types-catamorphism</guid>
      </item>
    
      <item>
        <title>Yes silver bullet</title>
        <link>https://blog.ploeh.dk/2019/07/01/yes-silver-bullet/</link>
        <pubDate>Mon, 01 Jul 2019 07:38:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;Since Fred Brooks published his essay, I believe that we, contrary to his prediction, have witnessed several silver bullets.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I've been rereading &lt;a href=&quot;https://en.wikipedia.org/wiki/Fred_Brooks&quot;&gt;Fred Brooks&lt;/a&gt;'s 1986 essay &lt;a href=&quot;https://en.wikipedia.org/wiki/No_Silver_Bullet&quot;&gt;No Silver Bullet&lt;/a&gt; because I've become increasingly concerned that people seem to draw the wrong conclusions from it. &lt;a href=&quot;https://martinfowler.com/bliki/SemanticDiffusion.html&quot;&gt;Semantic diffusion&lt;/a&gt; seems to have set in. These days, when people state something along the lines that there's &lt;em&gt;no silver bullet in software development&lt;/em&gt;, I often get the impression that they mean that there's no panacea.
	&lt;/p&gt;
	&lt;p&gt;
		Indeed; I agree. There's no miracle cure that will magically make all problems in software development go away. That's not what the essay states, however. It is, fortunately, more subtle than that.
	&lt;/p&gt;
	&lt;h3 id=&quot;712292e6c9c34663801dd40b4f278d3d&quot;&gt;
		No silver bullet reread &lt;a href=&quot;#712292e6c9c34663801dd40b4f278d3d&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		It's a great essay. It's not my intent to dispute the central argument of the essay, but I think that Brooks made one particular assumption that I disagree with. That doesn't make me smarter in any way. He wrote the essay in 1986. I'm writing this in 2019, with the benefit of the experience of all the years in-between. Hindsight is 20-20, so anyone could make the observations that I do here.
	&lt;/p&gt;
	&lt;p&gt;
		Before we get to that, though, a brief summary of the essence of the essay is in order. In short, the conclusion is this:
		&lt;blockquote&gt;
			&lt;p&gt;
				&quot;There is no single development, in either technology or management technique, which by itself promises even one order-of-magnitude improvement within a decade in productivity, in reliability, in simplicity.&quot;
			&lt;/p&gt;
			&lt;footer&gt;&lt;cite&gt;Fred Brooks, &lt;em&gt;No Silver Bullet&lt;/em&gt;, 1986&lt;/cite&gt;&lt;/footer&gt;
		&lt;/blockquote&gt;
		The beginning of the essay is a brilliant analysis of the reasons why software development is inherently difficult. If you read this together with Jack Reeves &lt;em&gt;What Is Software Design?&lt;/em&gt; (available various places on the internet, or as an appendix in &lt;a href=&quot;http://amzn.to/19W4JHk&quot;&gt;APPP&lt;/a&gt;), you'll probably agree that there's an inherent complexity to software development that no invention is likely to dispel.
	&lt;/p&gt;
	&lt;p&gt;
		Ostensibly in the tradition of &lt;a href=&quot;https://en.wikipedia.org/wiki/Aristotle&quot;&gt;Aristotle&lt;/a&gt;, Brooks distinguishes between &lt;em&gt;essential&lt;/em&gt; and &lt;em&gt;accidental&lt;/em&gt; complexity. This distinction is central to his argument, so it's worth discussing for a minute.
	&lt;/p&gt;
	&lt;p&gt;
		Software development problems are complex, i.e. made up of many interacting sub-problems. Some of that complexity is &lt;em&gt;accidental&lt;/em&gt;. This doesn't imply randomness or sloppiness, but only that the complexity isn't inherent to the problem; that it's only the result of our (human) failure to achieve perfection.
	&lt;/p&gt;
	&lt;p&gt;
		If you imagine that you could whittle away all the accidental complexity, you'd ultimately reach a point where, in the words of Saint Exupéry, &lt;em&gt;there is nothing more to remove&lt;/em&gt;. What's left is the &lt;em&gt;essential&lt;/em&gt; complexity.
	&lt;/p&gt;
	&lt;p&gt;
		Brooks' conjecture is that a typical software development project comes with both essential and accidental complexity. In his 1995 reflections &lt;em&gt;&quot;No Silver Bullet&quot; Refired&lt;/em&gt; (available in &lt;a href=&quot;http://bit.ly/mythical-man-month&quot;&gt;The Mythical Man-Month&lt;/a&gt;), he clarifies what he already implied in 1986:
		&lt;blockquote&gt;
			&lt;p&gt;
				&quot;It is my opinion, and that is all, that the accidental or representational part of the work is now down to about half or less of the total.&quot;
			&lt;/p&gt;
			&lt;footer&gt;&lt;cite&gt;Fred Brooks, &lt;em&gt;&quot;No Silver Bullet&quot; Refired&lt;/em&gt;, 1995&lt;/cite&gt;&lt;/footer&gt;
		&lt;/blockquote&gt;
		This I fundamentally disagree with, but more on that later. It makes sense to me to graphically represent the argument like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/essential-accidental-complexity-shells-brooks-scenario.png&quot; alt=&quot;Some, but not much, accidental complexity as a shell around essential complexity.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The way that I think of Brooks' argument is that any software project contains some essential and some accidental complexity. For a given project, the size of the essential complexity is fixed.
	&lt;/p&gt;
	&lt;p&gt;
		Brooks believes that less than half of the overall complexity is accidental:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/essential-accidental-complexity-pie-chart-brooks-scenario.png&quot; alt=&quot;Essential and accidental complexity pie chart.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While a pie chart better illustrates the supposed ratio between the two types of complexity, I prefer to view Brooks' arguments as the first diagram, above. In that visualisation, the essential complexity is a core of fixed size, while accidental complexity is something you can work at removing. If you keep improving your process and technology, you may, conceptually, be able to remove (almost) all of it.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/essential-almost-no-accidental-complexity-shells.png&quot; alt=&quot;Essential complexity with a very thin shell of accidental complexity.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Brooks' point, with which I agree, is that if the essential complexity is inherent, then you can't reduce the size of it. The only way to decrease the overall complexity is to reduce the accidental complexity.
	&lt;/p&gt;
	&lt;p&gt;
		If you agree with the assessment that less than half of the overall complexity in modern software development is accidental, then it follows that no dramatic improvements are available. Even if you remove all accidental complexity, you've only reduced overall complexity by, say, forty percent.
	&lt;/p&gt;
	&lt;h3 id=&quot;d8e6f84d104b4ff6ad6b5473e46a4e30&quot;&gt;
		Accidental complexity abounds &lt;a href=&quot;#d8e6f84d104b4ff6ad6b5473e46a4e30&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		I find Brooks' arguments compelling. I do not, however, accept the premise that there's only little accidental complexity left. Instead of the above diagrams, I believe that the situation looks more like this (not to scale):
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/accidental-complexity-with-tiny-core-of-essential-complexity.png&quot; alt=&quot;Accidental complexity with a tiny core of essential complexity.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I think that most of the complexity in software development is accidental. I'm not sure about today, but I believe that I have compelling evidence that this was the case in 1986, so I don't see why it shouldn't still be the case.
	&lt;/p&gt;
	&lt;p&gt;
		To be clear, this is all anecdotal, since I don't believe that software development is quantifiable. In the essay, Brooks explicitly talks about the &lt;em&gt;invisibility&lt;/em&gt; of software. Software is pure &lt;em&gt;thought stuff;&lt;/em&gt; you can't measure it. I discuss this in my &lt;a href=&quot;https://cleancoders.com/episode/humane-code-real-episode-1/show&quot;&gt;Humane Code video&lt;/a&gt;, but I also recommend that you read &lt;a href=&quot;http://bit.ly/leprechauns-of-software-engineering&quot;&gt;The Leprechauns of Software Engineering&lt;/a&gt; if you have any illusions that we, as an industry, have any reliable measurements of productivity.
	&lt;/p&gt;
	&lt;p&gt;
		Brooks predicts that, within the decade (from 1986 to 1996), there would be no single development that would increase productivity with an order of magnitude, i.e. by a factor of at least ten. Ironically, when he wrote &lt;em&gt;&quot;No Silver Bullet&quot; Refired&lt;/em&gt; in 1995, at least two such developments were already in motion.
	&lt;/p&gt;
	&lt;p&gt;
		We can't blame Brooks for not identifying those developments, because in 1995, their impact was not yet apparent. Again, hindsight is 20-20.
	&lt;/p&gt;
	&lt;p&gt;
		Neither of these two developments are purely technological, although technology plays a role. Notice, though, that Brooks' prediction included &lt;em&gt;technology or management technique&lt;/em&gt;. It's in the interaction between technology and the humane that the orders-of-magnitude developments emerged.
	&lt;/p&gt;
	&lt;h3 id=&quot;1d23f6fb89884b6d9833ce09d68a3b0f&quot;&gt;
		World Wide Web &lt;a href=&quot;#1d23f6fb89884b6d9833ce09d68a3b0f&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		I have a dirty little secret. In the beginning of my programming career, I became quite the expert on a programming framework called &lt;a href=&quot;https://en.wikipedia.org/wiki/Microsoft_Commerce_Server&quot;&gt;Microsoft Commerce Server&lt;/a&gt;. In fact, I co-authored a chapter of &lt;a href=&quot;https://amzn.to/2CpE4rr&quot;&gt;Professional Commerce Server 2000 Programming&lt;/a&gt;, and in 2003 I received an &lt;a href=&quot;https://mvp.microsoft.com&quot;&gt;MVP&lt;/a&gt; award as an acknowledgement of my work in the Commerce Server community (such as it were; it was mostly on &lt;a href=&quot;https://en.wikipedia.org/wiki/Usenet&quot;&gt;Usenet&lt;/a&gt;).
	&lt;/p&gt;
	&lt;p&gt;
		The Commerce Server framework was a black box. This was long before Microsoft embraced open source, and while there was a bit of official documentation, it was superficial; it was mostly of the &lt;em&gt;getting-started&lt;/em&gt; kind.
	&lt;/p&gt;
	&lt;p&gt;
		Over several years, I managed to figure out how the framework really worked, and thus, how one could extend it. This was a painstaking process. Since it was a black box, I couldn't just go and read the code to figure out how it worked. The framework was written in C++ and Visual Basic, so there wasn't even IL code to decompile.
	&lt;/p&gt;
	&lt;p&gt;
		I had one window into the framework. It relied on SQL Server, and I could attach the profiler tool to spy on its interaction with the database. Painstakingly, over several years, I managed to wrest the framework's secrets from it.
	&lt;/p&gt;
	&lt;p&gt;
		I wasted much time doing detective work like that.
	&lt;/p&gt;
	&lt;p&gt;
		In general, programming in the late nineties and early two-thousands was less productive, not because the languages or tools were orders-of-magnitude worse than today, but because when you hit a snag, you were in trouble.
	&lt;/p&gt;
	&lt;p&gt;
		These days, if you run into a problem beyond your abilities, you can ask for help on the World Wide Web. Usually, you'll find an existing answer on &lt;a href=&quot;https://stackoverflow.com&quot;&gt;Stack Overflow&lt;/a&gt;, and you'll be able to proceed without too much delay.
	&lt;/p&gt;
	&lt;p&gt;
		Compared to twenty years ago, I believe that the World Wide Web has increased my productivity more than ten-fold. While it also existed in 1995, there wasn't much content. It's not the technology itself that provides the productivity increase, but rather the synergy of technology and human knowledge.
	&lt;/p&gt;
	&lt;p&gt;
		I think that Brooks vastly underestimated how much time one can waste when one is stuck. That's a sort of accidental complexity, although in the development process rather than in the technology itself.
	&lt;/p&gt;
	&lt;h3 id=&quot;a3b19483cd6a4c509d8c3a77fe324872&quot;&gt;
		Automated testing &lt;a href=&quot;#a3b19483cd6a4c509d8c3a77fe324872&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		In the late nineties, I was developing web sites (with Commerce Server). When I wanted to run my code to see if it worked, I'd launch the web site on my laptop, log in, click around and enter data until I was convinced that the functionality was working as it should. Most of the time, however, it wasn't, so I'd change a bit of the code, and go through the same process again.
	&lt;/p&gt;
	&lt;p&gt;
		I think that's a common way to 'test' software; at least, it was back then.
	&lt;/p&gt;
	&lt;p&gt;
		While you could get good at going through these motions quickly, verifying a single, or a handful of related functionalities, could easily take at least a couple of seconds, and usually more like half a minute.
	&lt;/p&gt;
	&lt;p&gt;
		If you had dozens, or even hundreds, of different scenarios to address, you obviously wouldn't run through them all every time you changed the code. At the very best, you'd click your way through three of four usage scenarios that you thought were relevant to the change you'd made. Other functionality, earlier declared &lt;em&gt;done&lt;/em&gt;, you just considered to be unaffected.
	&lt;/p&gt;
	&lt;p&gt;
		Needless to say, regressions were regular occurrences.
	&lt;/p&gt;
	&lt;p&gt;
		In 2003 I discovered test-driven development, and through that, automated testing. While you can't directly compare unit tests with whole usage scenarios, I think it's fair to compare something like automated integration tests or user-scenario tests (whatever you want to call them) with manually clicking through an application.
	&lt;/p&gt;
	&lt;p&gt;
		Even an integration test, if written properly, can verify a scenario &lt;em&gt;at least&lt;/em&gt; ten times faster than you can do it by hand. A more realistic estimate is probably hundred times faster, or more.
	&lt;/p&gt;
	&lt;p&gt;
		Granted, you have to write the automated test as well, and I know that it's not always trivial. Still, once you have an automated test suite in place, you can run it all the time.
	&lt;/p&gt;
	&lt;p&gt;
		I never ran through &lt;em&gt;all&lt;/em&gt; usage scenarios when I manually 'tested' my software. With automated tests, I do. This saves me from most regressions.
	&lt;/p&gt;
	&lt;p&gt;
		This improvement is, in my opinion, a no-brainer. It's easily a factor ten improvement. All the time wasted manually 'testing' the software, plus the time wasted fixing regressions, can be put to better use.
	&lt;/p&gt;
	&lt;p&gt;
		At the time Brooks was writing his own retrospective (in 1995), Kent Beck was beginning to talk to other people about test-driven development. As is a common theme in this article, hindsight is 20-20.
	&lt;/p&gt;
	&lt;h3 id=&quot;c7ca9269cce04b3ab934c97bc8cf0328&quot;&gt;
		Honourable mentions &lt;a href=&quot;#c7ca9269cce04b3ab934c97bc8cf0328&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		There's been other improvements in software development since 1986. I considered including several other improvements as bona fide orders-of-magnitude improvements, but I think that's probably going too far. Each of the following developments have, however, offered significant improvements:
		&lt;ul&gt;
			&lt;li&gt;
				&lt;strong&gt;Git.&lt;/strong&gt; It's surprising how much more productive Git can make you. While it's somewhat better than centralised source control systems at the functionality also available with those other systems, the productivity increase comes from all the new, unanticipated workflows it enables. Before I started using DVCS, I'd have lots of code that was commented out, so that I could experiment with various alternatives. With Git, I just create a new branch, or stash my changes, and experiment with abandon. While it's probably not a ten-fold increase in productivity, I believe it's the simplest technology change you can make to dramatically increase your productivity.
			&lt;/li&gt;
			&lt;li&gt;
				&lt;strong&gt;Garbage collection.&lt;/strong&gt; Since I've admitted that I worked with Microsoft Commerce Server, I've probably lost all credibility with my reader already, but let's see if I can win back a little. While Commerce Server programming involved &lt;a href=&quot;https://en.wikipedia.org/wiki/VBScript&quot;&gt;VBScript&lt;/a&gt; programming, it also often involved &lt;a href=&quot;https://en.wikipedia.org/wiki/Component_Object_Model&quot;&gt;COM&lt;/a&gt; programming, and I did quite a bit of that in C++. Having to make sure that you've cleaned up all memory after use is a bother. Garbage collection just makes this work go away. It's hardly a ten-fold improvement in productivity, but I do find it significant.
			&lt;/li&gt;
			&lt;li&gt;
				&lt;strong&gt;Agile software development.&lt;/strong&gt; The methodology of decreasing the feedback time between implementation and deployment has made me much more productive. I'm not interested in peddling any particular methodology like Scrum as much as just the general concept of getting rapid feedback. Particularly if you combine continuous delivery with Git, you have a powerful combination. Brooks already talked about incremental software development, and had some hopes attached to this as well. My personal experience can only agree with his sentiment. Again, probably not in itself a ten-fold increase in productivity, but enough that I wouldn't want to work on a project where rapid feedback and incremental development wasn't valued.
			&lt;/li&gt;
		&lt;/ul&gt;
		I'm probably forgetting lots of other improvements that have happened in the last decades. That's fine. The purpose of this article isn't to produce an exhaustive list, but rather to make the argument that significant improvements have been made since Brooks wrote his essay. I think it'd be folly, then, to believe that we've seen the last of such improvements.
	&lt;/p&gt;
	&lt;p&gt;
		Personally, I'm inclined to believe another order-of-magnitude improvement is right at our feet.
	&lt;/p&gt;
	&lt;h3 id=&quot;bd2d47d8dac2401e936ca7902bc9109d&quot;&gt;
		Statically typed functional programming &lt;a href=&quot;#bd2d47d8dac2401e936ca7902bc9109d&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		This section is conjecture on my part. The improvements I've so far covered are already realised (at least for those who choose to take advantage of them). The improvement I'll cover here is more speculative.
	&lt;/p&gt;
	&lt;p&gt;
		I believe that statically typed functional programming offers another order-of-magnitude improvement over existing software development. Twenty years ago, I believed that object-oriented programming was a good idea. I now believe that I was wrong about that, so it's possible that in another twenty years, I'll also believe that I was wrong about functional programming. Take the following for what it is.
	&lt;/p&gt;
	&lt;p&gt;
		When I carefully reread &lt;em&gt;No Silver Bullet&lt;/em&gt;, I got the distinct impression that Brooks considered low-level details of programming part of its essential complexity:
		&lt;blockquote&gt;
			&lt;p&gt;
				&quot;Much of the complexity in a software construct is, however, not due to conformity to the external world but rather to the implementation itself - its data structures, its algorithms, its connectivity.&quot;
			&lt;/p&gt;
			&lt;footer&gt;&lt;cite&gt;Fred Brooks, &lt;em&gt;&quot;No Silver Bullet&quot; Refired&lt;/em&gt;, 1995&lt;/cite&gt;&lt;/footer&gt;
		&lt;/blockquote&gt;
		It's unreasonable to blame anyone writing in 1986, or 1995 for that matter, to think that &lt;code&gt;for&lt;/code&gt; loops, variables, program state, and such other programming stables were anything but essential parts of the complexity of developing software.
	&lt;/p&gt;
	&lt;p&gt;
		Someone, unfortunately I forget who, once made the point that all mainstream programming languages are layers of abstractions of how a CPU works. Assembly language is basically just mnemonics on top of a CPU instruction set, then C can be thought of as an abstraction over assembly language, C++ as the next step in abstraction, Java and C# as sort of abstractions of C++, and so on. The origin of the design is the physical CPU. You could say that these languages are designed in a bottom-up fashion.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/imperative-bottom-up-functional-top-down.png&quot; alt=&quot;Imperative languages depicted as designed bottom-up, and functional languages as designed top-down.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Some functional languages (perhaps most famously &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;, but also &lt;a href=&quot;https://en.wikipedia.org/wiki/APL_(programming_language)&quot;&gt;APL&lt;/a&gt;, and, possibly, &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;) are designed in a much more top-down fashion. You start with mathematical abstractions like &lt;a href=&quot;https://en.wikipedia.org/wiki/Category_theory&quot;&gt;category theory&lt;/a&gt; and then figure out how to crystallise the theory into a programming language, and then again, via more layers of abstractions, how to turn the abstract language into machine code.
	&lt;/p&gt;
	&lt;p&gt;
		The more you learn about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure&lt;/a&gt; functional alternative to programming, the more you begin to see mutable program state, variables, &lt;code&gt;for&lt;/code&gt; loops, and similar language constructs merely as artefacts of the underlying model. Brooks, I think, thought of these as part of the essential complexity of programming. I don't think that that's the case. You can get by just fine with other abstractions instead.
	&lt;/p&gt;
	&lt;p&gt;
		Besides, Brooks writes, under the heading of &lt;em&gt;Complexity:&lt;/em&gt;
		&lt;blockquote&gt;
			&lt;p&gt;
				&quot;From the complexity comes the difficulty of enumerating, much less understanding, all the possible states of the program, and from that comes the unreliability. From the complexity of the functions comes the difficulty of invoking those functions, which makes programs hard to use.&quot;
			&lt;/p&gt;
			&lt;footer&gt;&lt;cite&gt;Fred Brooks, &lt;em&gt;No Silver Bullet&lt;/em&gt;, 1986&lt;/cite&gt;&lt;/footer&gt;
		&lt;/blockquote&gt;
		When he writes &lt;em&gt;functions&lt;/em&gt;, I don't think that he means functions in the Haskell sense. I think that he means &lt;em&gt;operations&lt;/em&gt;, &lt;em&gt;procedures&lt;/em&gt;, or &lt;em&gt;methods&lt;/em&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		Indeed, when you look at a C# method signature like the following, it's hard to enumerate, understand, or remember, all that it does:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;?&amp;nbsp;TryAccept(&lt;span style=&quot;color:#2b91af;&quot;&gt;Reservation&lt;/span&gt;&amp;nbsp;reservation);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		If this is a high-level function, many things could happen when you call that method. It could change the state of a database. It could send an email. It could mutate a variable. Not only that, but the behaviour could depend on non-deterministic factors, such as the date, time of day, or just raw randomness. Finally, how should you handle the return value? What does it mean if the return value is &lt;em&gt;null&lt;/em&gt;? What if it's not? Is &lt;code&gt;0&lt;/code&gt; a valid value? Are negative numbers valid? Are they different from positive values?
	&lt;/p&gt;
	&lt;p&gt;
		It is, indeed, difficult to enumerate all the possible states of such a function.
	&lt;/p&gt;
	&lt;p&gt;
		Consider, instead, a Haskell function with a type like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;tryAccept&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Int&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Reservation&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeT&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ReservationsProgram&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Int&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		What happens if you invoke this function? It returns a value. Does it send any emails? Does it mutate any state? No, it can't, because the static type informs us that this is a pure function. If any programmer, anywhere inside of the function, or the functions it calls, or functions they call, etc. tried to do something impure, it wouldn't have compiled.
	&lt;/p&gt;
	&lt;p&gt;
		Can we enumerate the states of the program? Certainly. We just have to figure out what &lt;code&gt;ReservationsProgram&lt;/code&gt; is. After following a few types, we find this statically typed enumeration:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;ReservationsInstruction&amp;nbsp;next&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IsReservationInFuture&amp;nbsp;Reservation&amp;nbsp;(Bool&amp;nbsp;-&amp;gt;&amp;nbsp;next)
&amp;nbsp;&amp;nbsp;|&amp;nbsp;ReadReservations&amp;nbsp;UTCTime&amp;nbsp;([Reservation]&amp;nbsp;-&amp;gt;&amp;nbsp;next)
&amp;nbsp;&amp;nbsp;|&amp;nbsp;Create&amp;nbsp;Reservation&amp;nbsp;(Int&amp;nbsp;-&amp;gt;&amp;nbsp;next)
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;Functor&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Essentially, there's three 'actions' that this type enables. The &lt;code&gt;tryAccept&lt;/code&gt; function returns the &lt;code&gt;ReservationsProgram&lt;/code&gt; inside of a &lt;code&gt;MaybeT&lt;/code&gt; container, so there's a fourth option that something short-circuits along the way.
	&lt;/p&gt;
	&lt;p&gt;
		You don't even have to keep track of this yourself. The compiler keeps you honest. Whenever you invoke the &lt;code&gt;tryAccept&lt;/code&gt; function, the compiler will insist that you write code that can handle all possible outcomes. If you turn on the right compiler flags, the code is not going to compile if you don't.
	&lt;/p&gt;
	&lt;p&gt;
		(Both code examples are taken from &lt;a href=&quot;https://github.com/ploeh/dependency-injection-revisited&quot;&gt;the same repository&lt;/a&gt;.)
	&lt;/p&gt;
	&lt;p&gt;
		Haskellers jokingly declare that &lt;em&gt;if Haskell code compiles, it works&lt;/em&gt;. While humorous, there's a kernel of truth in that. An advanced type system can carry much information about the behaviour of a program. Some people, particularly programmers who come from a dynamically typed background, find Haskell's type system rigid. That's not an unreasonable criticism, but often, in dynamically typed languages, you have to write many automated tests to ensure that your program behaves as desired, and that it correctly handles various edge cases. A type system like Haskell's, on the other hand, embeds those rules in types instead of in tests.
	&lt;/p&gt;
	&lt;p&gt;
		While you should still write automated tests for Haskell programs, fewer are needed. How many fewer? Compared to C-based languages, a factor ten isn't an unreasonable guess.
	&lt;/p&gt;
	&lt;p&gt;
		After a few false starts, in 2014 I finally decided that &lt;a href=&quot;https://fsharp.org&quot;&gt;F#&lt;/a&gt; would be my default choice of language on .NET. The reason for that decision was that I felt so much more productive in F# compared to C#. While F#'s type system doesn't embed information about pure versus impure functions, it does support &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;sum types&lt;/a&gt;, which is what enables the sort of compile-time &lt;em&gt;enumeration&lt;/em&gt; that Brooks discusses.
	&lt;/p&gt;
	&lt;p&gt;
		F# is still my .NET language of choice, but I find that I mostly 'think in' Haskell these days. My conjecture is that a sufficiently advanced type system (like Haskell's) could easily represent another order-of-magnitude improvement over mainstream imperative languages.
	&lt;/p&gt;
	&lt;h3 id=&quot;a75ae35933314755b1a0cdb665262bc5&quot;&gt;
		Improvements for those who want them &lt;a href=&quot;#a75ae35933314755b1a0cdb665262bc5&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The essay &lt;em&gt;No Silver Bullet&lt;/em&gt; is a perspicacious work. I think more people should read at least the first part, where Brooks explains why software development is hard. I find that analysis brilliant, and I agree: software development presupposes essential complexity. It's inherently hard.
	&lt;/p&gt;
	&lt;p&gt;
		There's no reason to make it harder than it has to be, though.
	&lt;/p&gt;
	&lt;p&gt;
		More than once, I've discussed productivity improvements with people, only to be met with the dismissal that 'there's no silver bullet'.
	&lt;/p&gt;
	&lt;p&gt;
		Granted, there's no magical solution that will solve all problems with software development, but that doesn't mean that improvements can't be had.
	&lt;/p&gt;
	&lt;p&gt;
		Consider the improvements I've argued for here. Everyone now uses the World Wide Web and sites like Stack Overflow for research; that particular improvement is firmly embedded in all organisations. On the other hand, I still regularly talk to organisations that don't routinely use automated testing.
	&lt;/p&gt;
	&lt;p&gt;
		People still use centralised version control (like TFS or SVN). If there was ever a low-hanging fruit, changing to Git is one. Git is &lt;em&gt;free&lt;/em&gt;, and there's plenty of tools you can use to migrate your version history to it. There's also plenty of training and help to be had. Yes, it'll require a small investment to make the change, but the productivity increase is significant.
		&lt;blockquote&gt;
			&lt;p&gt;
				&quot;The future is already here — it's just not very evenly distributed.&quot;
			&lt;/p&gt;
			&lt;footer&gt;&lt;cite&gt;William Gibson&lt;/cite&gt;&lt;/footer&gt;
		&lt;/blockquote&gt;
		So it is with technology improvements. Automated testing is available, but not ubiquitous. Git is free, but still organisations stick to suboptimal version control. Haskell and F# are mature languages, yet programmers still program in C# or Java.
	&lt;/p&gt;
	&lt;h3 id=&quot;864e39a22bc84129bfecaafe33dd1757&quot;&gt;
		Summary &lt;a href=&quot;#864e39a22bc84129bfecaafe33dd1757&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The essay &lt;em&gt;No Silver Bullet&lt;/em&gt; was written in 1986, but seems to me to be increasingly misunderstood. When people today talk about it at all, it's mostly as an excuse to stay where they are. &quot;There's no silver bullets,&quot; they'll say.
	&lt;/p&gt;
	&lt;p&gt;
		The essay, however, doesn't argue that no improvements can be had. It only argues that no more order-of-magnitude improvements can be had.
	&lt;/p&gt;
	&lt;p&gt;
		In the present essay I argue that, since Brooks wrote &lt;em&gt;No Silver Bullet&lt;/em&gt;, more than one such improvement happened. Once the World Wide Web truly began furnishing &lt;em&gt;information at your fingertips&lt;/em&gt;, you could be more productive because you wouldn't be &lt;em&gt;stuck&lt;/em&gt; for days or weeks. Automated testing reduces the work that manual testers used to perform, as well as limiting regressions.
	&lt;/p&gt;
	&lt;p&gt;
		If you accept my argument, that order-of-magnitude improvements appeared after 1986, this implies that Brooks' premise was wrong. In that case, there's no reason to believe that we've seen the last significant improvement to software development.
	&lt;/p&gt;
	&lt;p&gt;
		I think that more such improvements await us. I suggest that statically typed functional programming offers such an advance, but if history teaches us anything, it seems that breakthroughs tend to be unpredictable.
	&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&quot;comments&quot;&gt;
	&lt;hr&gt;
	&lt;h2 id=&quot;comments-header&quot;&gt;
		Comments
	&lt;/h2&gt;
	&lt;div class=&quot;comment&quot; id=&quot;7e7e932f5eea47f3bab328c58e9d164a&quot;&gt;
		&lt;div class=&quot;comment-author&quot;&gt;&lt;a href=&quot;http://blog.strobaek.org&quot;&gt;Karsten Strøbæk&lt;/a&gt;&lt;/div&gt;
		&lt;div class=&quot;comment-content&quot;&gt;
			&lt;p&gt;
				As always I enjoy reading your blog, even though I don't understand half of it most of the time. Or is that most of it half of the time? Allow me to put a few observations forward.
			&lt;/p&gt;
			&lt;p&gt;
				First I should confess, that I have actually not read the whole of Brook's essay. When I initially tried I got about half way through; it sounds like I should make another go at it. That of course will not stop me from commenting on the above.
			&lt;/p&gt;
			&lt;p&gt;
				Brook talks about complexity. To me designing and implementing a software system is not complex. Quantum physics is complex. Flying an airplane is difficult. Software development may be difficult depending on the task at hand (and unfortunately the qualifications of the team), but I would argue that it at most falls into the same category as flying an airplane.
			&lt;/p&gt;
			&lt;p&gt;
				I would properly also state, that there are no silver bullets. But like you I feel that people understand it incorrectly and there is definetely no reason for making things harder than they are. I think the examples of technology that helps are excellent and exactly describe that things do move forward.
			&lt;/p&gt;
			&lt;p&gt;
				That being said, it does not take away the creativity of the right decomposition, the responsibility for getting the use cases right, and especially the liability for getting it wrong. Sadly especially the last of overlooked. People should be reminded of where the phrase 'live under the bridge' comes from.
			&lt;/p&gt;
			&lt;p&gt;
				To end my ramblins, I would also look a little into the future. As you know I am somewhat sceptial about machine learning and AI. However, looking at the recent break throughs and use cases in these areas, I would not be surprised of a future where software development is done by 'an AI' assemblying pre-defined 'entities' to create the software we need. Like an F16 cannot be flown without a computer, future software cannot be created by a human. 
			&lt;/p&gt;
		&lt;/div&gt;
		&lt;div class=&quot;comment-date&quot;&gt;2019-07-04 18:29:00 UTC&lt;/div&gt;
	&lt;/div&gt;

	&lt;div class=&quot;comment&quot; id=&quot;756066e5cb0e42368ff9eeb9569fa47f&quot;&gt;
	    &lt;div class=&quot;comment-author&quot;&gt;&lt;a href=&quot;/&quot;&gt;Mark Seemann&lt;/a&gt;&lt;/div&gt;
	    &lt;div class=&quot;comment-content&quot;&gt;
	    	&lt;p&gt;
	    		Karsten, thank you for writing. I'm not inclined to agree that software development falls into the same category of complexity as flying a plane. It seems to me to be orders of magnitudes more complex.
	    	&lt;/p&gt;
	    	&lt;p&gt;
	    		Just look at error rates.
	    	&lt;/p&gt;
	    	&lt;p&gt;
	    		Would you ever board an air plane if flying had error rates similar to those observed in software development? Would you fly even if only one percent of all flights ended with plane crash?
	    	&lt;/p&gt;
	    	&lt;p&gt;
	    		In reality, flying is extremely safe. Would you claim that software development is as safe, predictable, and manageable as flying?
	    	&lt;/p&gt;
	    	&lt;p&gt;
	    		I see no evidence of that.
	    	&lt;/p&gt;
	    	&lt;p&gt;
	    		Are pilots significantly more capable human beings than software developers, or does something else explain the discrepancy in failure rates?
	    	&lt;/p&gt;
	    &lt;/div&gt;
	    &lt;div class=&quot;comment-date&quot;&gt;2019-07-05 15:47 UTC&lt;/div&gt;
	&lt;/div&gt;
	
	&lt;div class=&quot;comment&quot; id=&quot;7e7e932f5eea47f3bab328c58e9d164b&quot;&gt;
		&lt;div class=&quot;comment-author&quot;&gt;&lt;a href=&quot;http://blog.strobaek.org&quot;&gt;Karsten Strøbæk&lt;/a&gt;&lt;/div&gt;
		&lt;div class=&quot;comment-content&quot;&gt;
			&lt;p&gt;
				Hi Mark. The fact that error rates are higher in software development is more a statement to the bad state our industry is in and has been for a milinium or more.
			&lt;/p&gt;
			&lt;p&gt;
				Why do we except that we produce crappy systems or in your words software that is no safe, predictable, and manageble? The list of excuses is very long and the list of results is very short. We as an industry are simply doing it wrong, but most people prefers hand waving and marketing than simple and plausible heuristic.
			&lt;/p&gt;
			&lt;p&gt;
				To use your analogy about planes I could ask if you would fly with a place that had (only) been unit tested? Properly not as it is never the unit that fails, but always the integration. Should be test all integrations then? Yes, why not?
			&lt;/p&gt;
			&lt;p&gt;
				The used of planes or pilots (or whatever) may have been bad. My point was, the I do not see software development as complex.
			&lt;/p&gt;
		&lt;/div&gt;
		&lt;div class=&quot;comment-date&quot;&gt;2019-07-05 20:12 UTC&lt;/div&gt;
	&lt;/div&gt;

	&lt;div class=&quot;comment&quot; id=&quot;0df7412992fb499d915e6f4cdbb644a0&quot;&gt;
	    &lt;div class=&quot;comment-author&quot;&gt;&lt;a href=&quot;/&quot;&gt;Mark Seemann&lt;/a&gt;&lt;/div&gt;
	    &lt;div class=&quot;comment-content&quot;&gt;
	    	&lt;p&gt;
	    		Karsten, if we, as an industry, are doing it wrong, then why are we doing that?
	    	&lt;/p&gt;
	    	&lt;p&gt;
	    		And what should we be doing instead?
	    	&lt;/p&gt;
	    &lt;/div&gt;
	    &lt;div class=&quot;comment-date&quot;&gt;2019-07-06 16:00 UTC&lt;/div&gt;
	&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/07/01/yes-silver-bullet</guid>
      </item>
    
      <item>
        <title>Full binary tree catamorphism</title>
        <link>https://blog.ploeh.dk/2019/06/24/full-binary-tree-catamorphism/</link>
        <pubDate>Mon, 24 Jun 2019 06:00:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;The catamorphism for a full binary tree is a pair of functions.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This article is part of an &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;article series about catamorphisms&lt;/a&gt;. A catamorphism is a &lt;a href=&quot;/2017/10/04/from-design-patterns-to-category-theory&quot;&gt;universal abstraction&lt;/a&gt; that describes how to digest a data structure into a potentially more compact value.
	&lt;/p&gt;
	&lt;p&gt;
		This article presents the catamorphism for a full &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_tree&quot;&gt;binary tree&lt;/a&gt;, as well as how to identify it. The beginning of this article presents the catamorphism in C#, with examples. The rest of the article describes how to deduce the catamorphism. This part of the article presents my work in &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;. Readers not comfortable with Haskell can just read the first part, and consider the rest of the article as an optional appendix.
	&lt;/p&gt;
	&lt;p&gt;
		A &lt;em&gt;full binary tree&lt;/em&gt; (also known as a &lt;em&gt;proper&lt;/em&gt; or &lt;em&gt;plane&lt;/em&gt; binary tree) is a tree in which each node has either two or no branches.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/full-binary-tree-example.png&quot; alt=&quot;A full binary tree example diagram, with each node containing integers.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The diagram shows an example of a tree of integers. The left branch contains two children, of which the right branch again contains two sub-branches. The rest of the nodes are leaf-nodes with no sub-branches.
	&lt;/p&gt;
	&lt;h3 id=&quot;d6b9699fa3894a4383f9b2b2992a9e8f&quot;&gt;
		C# catamorphism &lt;a href=&quot;#d6b9699fa3894a4383f9b2b2992a9e8f&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As a C# representation of a full binary tree, I'll start with the &lt;code&gt;IBinaryTree&amp;lt;T&amp;gt;&lt;/code&gt; API from &lt;a href=&quot;/2018/08/13/a-visitor-functor&quot;&gt;A Visitor functor&lt;/a&gt;. The catamorphism is the &lt;code&gt;Accept&lt;/code&gt; method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;Accept&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTreeVisitor&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;visitor);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		So far in this article series, you've mostly seen &lt;a href=&quot;/2018/05/22/church-encoding&quot;&gt;Church-encoded&lt;/a&gt; catamorphisms, so a catamorphism represented as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Visitor_pattern&quot;&gt;Visitor&lt;/a&gt; may be too big of a cognitive leap. We know, however, from &lt;a href=&quot;/2018/06/25/visitor-as-a-sum-type&quot;&gt;Visitor as a sum type&lt;/a&gt; that a Visitor representation is isomorphic to a Church encoding. Since these are isomorphic, it's possible to refactor &lt;code&gt;IBinaryTree&amp;lt;T&amp;gt;&lt;/code&gt; to a Church encoding. The &lt;a href=&quot;https://github.com/ploeh/ChurchEncoding&quot;&gt;GitHub repository&lt;/a&gt; contains a series of commits that demonstrates how that refactoring works. Once you're done, you arrive at this &lt;code&gt;Match&lt;/code&gt; method, which is the refactored &lt;code&gt;Accept&lt;/code&gt; method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;node,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;leaf);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This method takes a pair of functions as arguments. The &lt;code&gt;node&lt;/code&gt; function deals with an internal node in the tree (the blue nodes in the above diagram), whereas the &lt;code&gt;leaf&lt;/code&gt; function deals with the leaf nodes (the green nodes in the diagram).
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;leaf&lt;/code&gt; function may be the easiest one to understand. A leaf node only contains a value of the type &lt;code&gt;T&lt;/code&gt;, so the only operation the function has to support is translating the &lt;code&gt;T&lt;/code&gt; value to a &lt;code&gt;TResult&lt;/code&gt; value. This is also the premise of the &lt;code&gt;Leaf&lt;/code&gt; class' implementation of the method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;item;
 
&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;node,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;leaf)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;leaf(item);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;node&lt;/code&gt; function is more tricky. It takes three input arguments, of the types &lt;code&gt;TResult&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;TResult&lt;/code&gt;. The roles of these are respectively &lt;em&gt;left&lt;/em&gt;, &lt;em&gt;item&lt;/em&gt;, and &lt;em&gt;right&lt;/em&gt;. This is a typical representation of a binary node. Since there's always a left and a right branch, you put the node's value in the middle. As was the case with the &lt;a href=&quot;/2019/06/10/tree-catamorphism&quot;&gt;tree catamorphism&lt;/a&gt;, the catamorphism function receives the branches as already-translated values; that is, both the left and right branch have already been translated to &lt;code&gt;TResult&lt;/code&gt; when &lt;code&gt;node&lt;/code&gt; is called. While it looks like magic, as always it's just the result of recursion:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;left;
&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;item;
&lt;span style=&quot;color:blue;&quot;&gt;private&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;readonly&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;right;
 
&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;node,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;leaf)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;node(left.Match(node,&amp;nbsp;leaf),&amp;nbsp;item,&amp;nbsp;right.Match(node,&amp;nbsp;leaf));
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This is the &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; class implementation of the &lt;code&gt;Match&lt;/code&gt; method. It calls &lt;code&gt;node&lt;/code&gt; and returns whatever it returns, but notice that as the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; arguments, if first, recursively, calls &lt;code&gt;left.Match&lt;/code&gt; and &lt;code&gt;right.Match&lt;/code&gt;. This is how it can call &lt;code&gt;node&lt;/code&gt; with the translated branches, as well as with the basic &lt;code&gt;item&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		The recursion stops and unwinds on &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; whenever one of those are &lt;code&gt;Leaf&lt;/code&gt; instances.
	&lt;/p&gt;
	&lt;h3 id=&quot;c64210d585c94cb78653b96380cbf0e6&quot;&gt;
		Examples &lt;a href=&quot;#c64210d585c94cb78653b96380cbf0e6&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can use &lt;code&gt;Match&lt;/code&gt; to implement most other behaviour you'd like &lt;code&gt;IBinaryTree&amp;lt;T&amp;gt;&lt;/code&gt; to have. In &lt;a href=&quot;/2018/08/13/a-visitor-functor&quot;&gt;the original article on the full binary tree functor&lt;/a&gt; you saw how to implement &lt;code&gt;Select&lt;/code&gt; with a Visitor, but now that the API is Church-encoded, you can derive &lt;code&gt;Select&lt;/code&gt; from &lt;code&gt;Match&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;Select&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;tree,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;selector)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(tree&amp;nbsp;==&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;null&lt;/span&gt;)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;throw&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;ArgumentNullException&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;nameof&lt;/span&gt;(tree));
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;(selector&amp;nbsp;==&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;null&lt;/span&gt;)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;throw&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;ArgumentNullException&lt;/span&gt;(&lt;span style=&quot;color:blue;&quot;&gt;nameof&lt;/span&gt;(selector));
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;tree.Match(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;node:&amp;nbsp;(l,&amp;nbsp;x,&amp;nbsp;r)&amp;nbsp;=&amp;gt;&amp;nbsp;Create(l,&amp;nbsp;selector(x),&amp;nbsp;r),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;leaf:&amp;nbsp;x&amp;nbsp;=&amp;gt;&amp;nbsp;Leaf(selector(x)));
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In the &lt;code&gt;leaf&lt;/code&gt; case, the &lt;code&gt;Select&lt;/code&gt; method simply calls &lt;code&gt;selector&lt;/code&gt; with the &lt;code&gt;x&lt;/code&gt; value it receives, and puts the resulting &lt;code&gt;TResult&lt;/code&gt; object into a new &lt;code&gt;Leaf&lt;/code&gt; object.
	&lt;/p&gt;
	&lt;p&gt;
		In the &lt;code&gt;node&lt;/code&gt; case, the lambda expression receives three arguments: &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; are the &lt;em&gt;already-translated&lt;/em&gt; left and right branches, so you only need to call &lt;code&gt;selector&lt;/code&gt; on &lt;code&gt;x&lt;/code&gt; and call the &lt;code&gt;Create&lt;/code&gt; helper method to produce a new &lt;code&gt;Node&lt;/code&gt; object.
	&lt;/p&gt;
	&lt;p&gt;
		You can also implement more specialised functionality, like calculating the sum of nodes, measuring the depth of the tree, and similar functions. You saw equivalent examples in the &lt;a href=&quot;/2019/06/10/tree-catamorphism&quot;&gt;previous article&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		For the examples in this article, I'll use the tree shown in the above diagram. Using static helper methods, you can write it like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;tree&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;BinaryTree&lt;/span&gt;.Create(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;BinaryTree&lt;/span&gt;.Create(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;BinaryTree&lt;/span&gt;.Leaf(42),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1337,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;BinaryTree&lt;/span&gt;.Create(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;BinaryTree&lt;/span&gt;.Leaf(2112),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;5040,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;BinaryTree&lt;/span&gt;.Leaf(1984))),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;BinaryTree&lt;/span&gt;.Leaf(90125));&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		To calculate the sum of all nodes, you can write a function like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;Sum(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;tree)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;tree.Match((l,&amp;nbsp;x,&amp;nbsp;r)&amp;nbsp;=&amp;gt;&amp;nbsp;l&amp;nbsp;+&amp;nbsp;x&amp;nbsp;+&amp;nbsp;r,&amp;nbsp;x&amp;nbsp;=&amp;gt;&amp;nbsp;x);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;leaf&lt;/code&gt; function just returns the value of the node, while the &lt;code&gt;node&lt;/code&gt; function adds the numbers together. It works for the above &lt;code&gt;tree&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; tree.Sum()
100642&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		To find the maximum value, you can write another extension method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;Max(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;tree)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;tree.Match((l,&amp;nbsp;x,&amp;nbsp;r)&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Math&lt;/span&gt;.Max(&lt;span style=&quot;color:#2b91af;&quot;&gt;Math&lt;/span&gt;.Max(l,&amp;nbsp;r),&amp;nbsp;x),&amp;nbsp;x&amp;nbsp;=&amp;gt;&amp;nbsp;x);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Again, the &lt;code&gt;leaf&lt;/code&gt; function just returns the value of the node. The &lt;code&gt;node&lt;/code&gt; function receives the value of the current node &lt;code&gt;x&lt;/code&gt;, as well as the already-found maximum value of the left branch and the right branch; it then returns the maximum of these three values:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; tree.Max()
90125&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		As was also the case for trees, both of these operations are part of the standard repertoire available via a data structure's &lt;em&gt;fold&lt;/em&gt;. That's not the case for the next two functions, which can't be implemented using a fold, but which can be defined with the catamorphism. The first is a function to count the leaves of a tree:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;CountLeaves&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;tree)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;tree.Match((l,&amp;nbsp;_,&amp;nbsp;r)&amp;nbsp;=&amp;gt;&amp;nbsp;l&amp;nbsp;+&amp;nbsp;r,&amp;nbsp;_&amp;nbsp;=&amp;gt;&amp;nbsp;1);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Since the &lt;code&gt;leaf&lt;/code&gt; function handles a leaf node, the number of leaf nodes in a leaf node is, by definition, &lt;em&gt;one&lt;/em&gt;. Thus, that function can ignore the value of the node and always return &lt;code&gt;1&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; function, on the other hand, receives the number of leaf nodes on the left-hand side (&lt;code&gt;l&lt;/code&gt;), the value of the current node, and the number of leaf nodes on the right-hand side (&lt;code&gt;r&lt;/code&gt;). Notice that since an internal node is never a leaf node, it doesn't count; instead, just add &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; together. Notice that, again, the value of the node itself is irrelevant.
	&lt;/p&gt;
	&lt;p&gt;
		How many leaf nodes does the above tree have?
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; tree.CountLeaves()
4&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can also measure the maximum depth of a tree:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;MeasureDepth&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IBinaryTree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;tree)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;tree.Match((l,&amp;nbsp;_,&amp;nbsp;r)&amp;nbsp;=&amp;gt;&amp;nbsp;1&amp;nbsp;+&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Math&lt;/span&gt;.Max(l,&amp;nbsp;r),&amp;nbsp;_&amp;nbsp;=&amp;gt;&amp;nbsp;0);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Like in the previous article, I've arbitrarily decided that the depth of a leaf node is &lt;em&gt;zero&lt;/em&gt;; therefore, the &lt;code&gt;leaf&lt;/code&gt; function always returns &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; function receives the depth of the left and right branches, and returns the maximum of those two values, plus one, since the current node adds one level of depth.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; tree.MeasureDepth()
3&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You may not have much need for working with full binary trees in your normal, day-to-day C# work, but I found it worthwhile to include this example for a couple of reasons. First, because the original of the API shows that a catamorphism may be hiding in a Visitor. Second, because binary trees are interesting, in that they're foldable &lt;a href=&quot;/2018/03/22/functors&quot;&gt;functors&lt;/a&gt;, but not monads.
	&lt;/p&gt;
	&lt;p&gt;
		Where does the catamorphism come from, though? How can you trust that the &lt;code&gt;Match&lt;/code&gt; method is the catamorphism?
	&lt;/p&gt;
	&lt;h3 id=&quot;d015bcc9afe742408d7c8ba6c6edce2a&quot;&gt;
		Binary tree F-Algebra &lt;a href=&quot;#d015bcc9afe742408d7c8ba6c6edce2a&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As in the &lt;a href=&quot;/2019/06/10/tree-catamorphism&quot;&gt;previous article&lt;/a&gt;, I'll use &lt;code&gt;Fix&lt;/code&gt; and &lt;code&gt;cata&lt;/code&gt; as explained in &lt;a href=&quot;https://bartoszmilewski.com&quot;&gt;Bartosz Milewski&lt;/a&gt;'s excellent &lt;a href=&quot;https://bartoszmilewski.com/2017/02/28/f-algebras/&quot;&gt;article on F-Algebras&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		As always, start with the underlying endofunctor. You can think of this one as a specialisation of the rose tree from the previous article:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;FullBinaryTreeF&amp;nbsp;a&amp;nbsp;c&amp;nbsp;=&amp;nbsp;LeafF&amp;nbsp;a&amp;nbsp;|&amp;nbsp;NodeF&amp;nbsp;c&amp;nbsp;a&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeF&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(LeafF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;LeafF&amp;nbsp;x
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;(NodeF&amp;nbsp;l&amp;nbsp;x&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;NodeF&amp;nbsp;(f&amp;nbsp;l)&amp;nbsp;x&amp;nbsp;(f&amp;nbsp;r)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		As usual, I've called the 'data' type &lt;code&gt;a&lt;/code&gt; and the carrier type &lt;code&gt;c&lt;/code&gt; (for &lt;em&gt;carrier&lt;/em&gt;). The &lt;code&gt;Functor&lt;/code&gt; instance as usual translates the carrier type; the &lt;code&gt;fmap&lt;/code&gt; function has the type &lt;code&gt;(c -&amp;gt; c1) -&amp;gt; FullBinaryTreeF a c -&amp;gt; FullBinaryTreeF a c1&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		As was the case when deducing the recent catamorphisms, Haskell isn't too happy about defining instances for a type like &lt;code&gt;Fix (FullBinaryTreeF a)&lt;/code&gt;. To address that problem, you can introduce a &lt;code&gt;newtype&lt;/code&gt; wrapper:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;newtype&lt;/span&gt;&amp;nbsp;FullBinaryTreeFix&amp;nbsp;a&amp;nbsp;=
&amp;nbsp;&amp;nbsp;FullBinaryTreeFix&amp;nbsp;{&amp;nbsp;unFullBinaryTreeFix&amp;nbsp;::&amp;nbsp;Fix&amp;nbsp;(FullBinaryTreeF&amp;nbsp;a)&amp;nbsp;}
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can define &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, and &lt;code&gt;Traversable&lt;/code&gt; instances (but not &lt;code&gt;Monad&lt;/code&gt;) for this type without resorting to any funky GHC extensions. Keep in mind that ultimately, the purpose of all this code is just to figure out what the catamorphism looks like. This code isn't intended for actual use.
	&lt;/p&gt;
	&lt;p&gt;
		A pair of helper functions make it easier to define &lt;code&gt;FullBinaryTreeFix&lt;/code&gt; values:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;fbtLeafF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;a
fbtLeafF&amp;nbsp;=&amp;nbsp;FullBinaryTreeFix&amp;nbsp;.&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;LeafF
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;fbtNodeF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;a
fbtNodeF&amp;nbsp;(FullBinaryTreeFix&amp;nbsp;l)&amp;nbsp;x&amp;nbsp;(FullBinaryTreeFix&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;FullBinaryTreeFix&amp;nbsp;$&amp;nbsp;Fix&amp;nbsp;$&amp;nbsp;NodeF&amp;nbsp;l&amp;nbsp;x&amp;nbsp;r&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In order to distinguish these helper functions from the ones that create &lt;code&gt;TreeFix a&lt;/code&gt; values, I prefixed them with &lt;code&gt;fbt&lt;/code&gt; (for &lt;em&gt;Full Binary Tree&lt;/em&gt;). &lt;code&gt;fbtLeafF&lt;/code&gt; creates a leaf node:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix FullBinaryTree&amp;gt; fbtLeafF &quot;fnaah&quot;
FullBinaryTreeFix {unFullBinaryTreeFix = Fix (LeafF &quot;fnaah&quot;)}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		&lt;code&gt;fbtNodeF&lt;/code&gt; is a helper function to create an internal node:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix FullBinaryTree&amp;gt; fbtNodeF (fbtLeafF 1337) 42 (fbtLeafF 2112)
FullBinaryTreeFix {unFullBinaryTreeFix = Fix (NodeF (Fix (LeafF 1337)) 42 (Fix (LeafF 2112)))}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;FullBinaryTreeFix&lt;/code&gt; type, or rather the underlying &lt;code&gt;FullBinaryTreeF a&lt;/code&gt; functor, is all you need to identify the catamorphism.
	&lt;/p&gt;
	&lt;h3 id=&quot;ced0da7dc61943b0be872ec79b4e3651&quot;&gt;
		Haskell catamorphism &lt;a href=&quot;#ced0da7dc61943b0be872ec79b4e3651&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		At this point, you have two out of three elements of an F-Algebra. You have an endofunctor (&lt;code&gt;FullBinaryTreeF a&lt;/code&gt;), and an object &lt;code&gt;c&lt;/code&gt;, but you still need to find a morphism &lt;code&gt;FullBinaryTreeF a c -&amp;gt; c&lt;/code&gt;. Notice that the algebra you have to find is the function that reduces the functor to its &lt;em&gt;carrier type&lt;/em&gt; &lt;code&gt;c&lt;/code&gt;, not the 'data type' &lt;code&gt;a&lt;/code&gt;. This takes some time to get used to, but that's how catamorphisms work. This doesn't mean, however, that you get to ignore &lt;code&gt;a&lt;/code&gt;, as you'll see.
	&lt;/p&gt;
	&lt;p&gt;
		As in the previous articles, start by writing a function that will become the catamorphism, based on &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;fullBinaryTreeF&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unFullBinaryTreeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(LeafF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(NodeF&amp;nbsp;l&amp;nbsp;x&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While this compiles, with its &lt;code&gt;undefined&lt;/code&gt; implementation of &lt;code&gt;alg&lt;/code&gt;, it obviously doesn't do anything useful. I find, however, that it helps me think. How can you return a value of the type &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;alg&lt;/code&gt;? You could pass a function argument to the &lt;code&gt;fullBinaryTreeF&lt;/code&gt; function and use it with &lt;code&gt;x&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;fullBinaryTreeF&amp;nbsp;fl&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unFullBinaryTreeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(LeafF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;fl&amp;nbsp;x
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(NodeF&amp;nbsp;l&amp;nbsp;x&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I called the function &lt;code&gt;fl&lt;/code&gt; for &lt;em&gt;function, leaf&lt;/em&gt;, because we're also going to need a function for the &lt;code&gt;NodeF&lt;/code&gt; case:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;fullBinaryTreeF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;(c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;(a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
fullBinaryTreeF&amp;nbsp;fn&amp;nbsp;fl&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unFullBinaryTreeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(LeafF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;fl&amp;nbsp;x
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(NodeF&amp;nbsp;l&amp;nbsp;x&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;fn&amp;nbsp;l&amp;nbsp;x&amp;nbsp;r&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This works. Since &lt;code&gt;cata&lt;/code&gt; has the type &lt;code&gt;Functor f =&amp;gt; (f a -&amp;gt; a) -&amp;gt; Fix f -&amp;gt; a&lt;/code&gt;, that means that &lt;code&gt;alg&lt;/code&gt; has the type &lt;code&gt;f a -&amp;gt; a&lt;/code&gt;. In the case of &lt;code&gt;FullBinaryTreeF&lt;/code&gt;, the compiler infers that the &lt;code&gt;alg&lt;/code&gt; function has the type &lt;code&gt;FullBinaryTreeF a c -&amp;gt; c&lt;/code&gt;, which is just what you need!
	&lt;/p&gt;
	&lt;p&gt;
		You can now see what the carrier type &lt;code&gt;c&lt;/code&gt; is for. It's the type that the algebra extracts, and thus the type that the catamorphism returns.
	&lt;/p&gt;
	&lt;p&gt;
		This, then, is the catamorphism for a full binary tree. As always, it's not the only possible catamorphism, since you can easily reorder the arguments to both &lt;code&gt;fullBinaryTreeF&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;, and &lt;code&gt;fl&lt;/code&gt;. These would all be isomorphic, though.
	&lt;/p&gt;
	&lt;h3 id=&quot;3f87d49db58f4cd59dec76a97d31c0d2&quot;&gt;
		Basis &lt;a href=&quot;#3f87d49db58f4cd59dec76a97d31c0d2&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can implement most other useful functionality with &lt;code&gt;treeF&lt;/code&gt;. Here's the &lt;code&gt;Functor&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;=&amp;nbsp;fullBinaryTreeF&amp;nbsp;(\l&amp;nbsp;x&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;fbtNodeF&amp;nbsp;l&amp;nbsp;(f&amp;nbsp;x)&amp;nbsp;r)&amp;nbsp;(fbtLeafF&amp;nbsp;.&amp;nbsp;f)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;fl&lt;/code&gt; function first invokes &lt;code&gt;f&lt;/code&gt;, followed by &lt;code&gt;fbtLeafF&lt;/code&gt;. The &lt;code&gt;fn&lt;/code&gt; function uses the &lt;code&gt;fbtNodeF&lt;/code&gt; helper function to create a new internal node. &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; are already-translated branches, so you just need to call &lt;code&gt;f&lt;/code&gt; with the node value &lt;code&gt;x&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		There's no &lt;code&gt;Monad&lt;/code&gt; instance for binary trees, because you can't flatten a binary tree of binary trees. You can, on the other hand, define a &lt;code&gt;Foldable&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Foldable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;foldMap&amp;nbsp;f&amp;nbsp;=&amp;nbsp;fullBinaryTreeF&amp;nbsp;(\l&amp;nbsp;x&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;l&amp;nbsp;&amp;lt;&amp;gt;&amp;nbsp;f&amp;nbsp;x&amp;nbsp;&amp;lt;&amp;gt;&amp;nbsp;r)&amp;nbsp;f&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;f&lt;/code&gt; function passed to &lt;code&gt;foldMap&lt;/code&gt; has the type &lt;code&gt;Monoid m =&amp;gt; (a -&amp;gt; m)&lt;/code&gt;, so the &lt;code&gt;fl&lt;/code&gt; function that handles leaf nodes simply calls &lt;code&gt;f&lt;/code&gt; with the contents of the node. The &lt;code&gt;fn&lt;/code&gt; function receives two branches already translated to &lt;code&gt;m&lt;/code&gt;, so it just has to call &lt;code&gt;f&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt; and combine all the &lt;code&gt;m&lt;/code&gt; values using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Traversable&lt;/code&gt; instance follows right on the heels of &lt;code&gt;Foldable&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Traversable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;sequenceA&amp;nbsp;=&amp;nbsp;fullBinaryTreeF&amp;nbsp;(liftA3&amp;nbsp;fbtNodeF)&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;fbtLeafF)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		There are operations on binary trees that you can implement with a fold, but some that you can't. Consider the tree shown in the diagram at the beginning of the article. This is also the tree that the above C# examples use. In Haskell, using &lt;code&gt;FullBinaryTreeFix&lt;/code&gt;, you can define that tree like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;tree&amp;nbsp;=&amp;nbsp;
&amp;nbsp;&amp;nbsp;fbtNodeF
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(fbtNodeF
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(fbtLeafF&amp;nbsp;42)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1337
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(fbtNodeF
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(fbtLeafF&amp;nbsp;2112)
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;5040
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(fbtLeafF&amp;nbsp;1984)))
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(fbtLeafF&amp;nbsp;90125)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Since &lt;code&gt;FullBinaryTreeFix&lt;/code&gt; is &lt;code&gt;Foldable&lt;/code&gt;, and that type class already comes with &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;maximum&lt;/code&gt; functions, no further work is required to repeat the first two of the above C# examples:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix FullBinaryTree&amp;gt; sum tree
100642
Prelude Fix FullBinaryTree&amp;gt; maximum tree
90125&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Counting leaves, or measuring the depth of a tree, on the other hand, is impossible with the &lt;code&gt;Foldable&lt;/code&gt; instance, but can be implemented using the catamorphism:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;countLeaves&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Num&lt;/span&gt;&amp;nbsp;n&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;n
countLeaves&amp;nbsp;=&amp;nbsp;fullBinaryTreeF&amp;nbsp;(\l&amp;nbsp;_&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;l&amp;nbsp;+&amp;nbsp;r)&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;const&lt;/span&gt;&amp;nbsp;1)
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;treeDepth&lt;/span&gt;&amp;nbsp;::&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;Ord&lt;/span&gt;&amp;nbsp;n,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Num&lt;/span&gt;&amp;nbsp;n)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;FullBinaryTreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;n
treeDepth&amp;nbsp;=&amp;nbsp;fullBinaryTreeF&amp;nbsp;(\l&amp;nbsp;_&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;1&amp;nbsp;+&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;max&lt;/span&gt;&amp;nbsp;l&amp;nbsp;r)&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;const&lt;/span&gt;&amp;nbsp;0)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The reasoning is the same as already explained in the above C# examples. The functions also produce the same results:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix FullBinaryTree&amp;gt; countLeaves tree
4
Prelude Fix FullBinaryTree&amp;gt; treeDepth tree
3&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This, hopefully, illustrates that the catamorphism is more capable, and that the fold is just a (list-biased) specialisation.
	&lt;/p&gt;
	&lt;h3 id=&quot;81b3e77b6fbe4760bc8c74805e4edba8&quot;&gt;
		Summary &lt;a href=&quot;#81b3e77b6fbe4760bc8c74805e4edba8&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The catamorphism for a full binary tree is a pair of functions. One function handles internal nodes, while the other function handles leaf nodes.
	&lt;/p&gt;
	&lt;p&gt;
		I thought it was interesting to show this example for two reasons: First, the original example was a Visitor implementation, and I think it's worth realising that a Visitor's &lt;code&gt;Accept&lt;/code&gt; method can also be viewed as a catamorphism. Second, a binary tree is an example of a data structure that has a fold, but isn't a monad.
	&lt;/p&gt;
	&lt;p&gt;
		All articles in the article series have, so far, covered data structures well-known from computer science. The next example will, on the other hand, demonstrate that even completely ad-hoc domain-specific data structures have catamorphisms.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;strong&gt;Next:&lt;/strong&gt; &lt;a href=&quot;/2019/07/08/payment-types-catamorphism&quot;&gt;Payment types catamorphism&lt;/a&gt;.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/06/24/full-binary-tree-catamorphism</guid>
      </item>
    
      <item>
        <title>Composition Root location</title>
        <link>https://blog.ploeh.dk/2019/06/17/composition-root-location/</link>
        <pubDate>Mon, 17 Jun 2019 05:55:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;A Composition Root should be located near the point where user code first executes.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Prompted by a recent Internet discussion, my &lt;a href=&quot;https://amzn.to/2TE8tJx&quot;&gt;DIPPP&lt;/a&gt; co-author &lt;a href=&quot;https://blogs.cuttingedge.it/steven/&quot;&gt;Steven van Deursen&lt;/a&gt; wrote to me in order to help clarify the &lt;a href=&quot;/2011/07/28/CompositionRoot&quot;&gt;Composition Root&lt;/a&gt; pattern.
	&lt;/p&gt;
	&lt;p&gt;
		In the email, Steven ponders whether it's defensible to use an API that &lt;a href=&quot;/2010/11/01/PatternRecognitionAbstractFactoryorServiceLocator&quot;&gt;looks like a Service Locator&lt;/a&gt; from within a unit test. He specifically calls out my article that describes the &lt;a href=&quot;/2013/03/11/auto-mocking-container&quot;&gt;Auto-mocking Container design pattern&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		In that article, I show how to use Castle Windsor's &lt;code&gt;Resolve&lt;/code&gt; method from within a unit test:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre style=&quot;margin: 0px;&quot;&gt;[&lt;span style=&quot;color: #2b91af;&quot;&gt;Fact&lt;/span&gt;]
&lt;span style=&quot;color: blue;&quot;&gt;public&lt;/span&gt; &lt;span style=&quot;color: blue;&quot;&gt;void&lt;/span&gt; SutIsController()
{
&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style=&quot;color: blue;&quot;&gt;var&lt;/span&gt; container = &lt;span style=&quot;color: blue;&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color: #2b91af;&quot;&gt;WindsorContainer&lt;/span&gt;().Install(&lt;span style=&quot;color: blue;&quot;&gt;new&lt;/span&gt; &lt;span style=&quot;color: #2b91af;&quot;&gt;ShopFixture&lt;/span&gt;());
&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style=&quot;color: blue;&quot;&gt;var&lt;/span&gt; sut = container.Resolve&amp;lt;&lt;span style=&quot;color: #2b91af;&quot;&gt;BasketController&lt;/span&gt;&amp;gt;();
&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span style=&quot;color: #2b91af;&quot;&gt;Assert&lt;/span&gt;.IsAssignableFrom&amp;lt;&lt;span style=&quot;color: #2b91af;&quot;&gt;IHttpController&lt;/span&gt;&amp;gt;(sut);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Is the test using a &lt;a href=&quot;/2010/02/03/ServiceLocatorisanAnti-Pattern&quot;&gt;Service Locator&lt;/a&gt;? If so, why is that okay? If not, why isn't it a Service Locator?
	&lt;/p&gt;
	&lt;p&gt;
		This article argues that that this use of &lt;code&gt;Resolve&lt;/code&gt; isn't a Service Locator.
	&lt;/p&gt;
	&lt;h3 id=&quot;e9a6c124fa1d4610ae57b3cba83254b0&quot;&gt;
		Entry points defined &lt;a href=&quot;#e9a6c124fa1d4610ae57b3cba83254b0&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The &lt;a href=&quot;/2011/07/28/CompositionRoot&quot;&gt;original article about the Composition Root pattern&lt;/a&gt; defines a Composition Root as the place where you compose your object graph(s). It repeatedly describes how this ought to happen in, or as close as possible to, the application's entry point. I believe that this definition is compatible with the pattern description given in &lt;a href=&quot;https://amzn.to/2TE8tJx&quot;&gt;our book&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		I do realise, however, that we may never have explicitly defined what an &lt;em&gt;entry point&lt;/em&gt; is.
	&lt;/p&gt;
	&lt;p&gt;
		In order to do so, it may be helpful to establish a bit of terminology. In the following, I'll use the terms &lt;em&gt;user code&lt;/em&gt; as opposed to &lt;em&gt;framework code&lt;/em&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		Much of the code you write probably runs within some sort of framework. If you're writing a web application, you're probably using a web framework. If you're writing a message-based application, you might be using some message bus, or actor, framework. If you're writing an app for a mobile device, you're probably using some sort of framework for that, too.
	&lt;/p&gt;
	&lt;p&gt;
		Even as a programmer, you're a &lt;em&gt;user&lt;/em&gt; of frameworks.
	&lt;/p&gt;
	&lt;p&gt;
		As I usually do, I'll use &lt;a href=&quot;http://tomasp.net&quot;&gt;Tomas Petricek&lt;/a&gt;'s distinction between &lt;a href=&quot;http://tomasp.net/blog/2015/library-frameworks&quot;&gt;libraries and frameworks&lt;/a&gt;. A library is a collection of APIs that you can call. A framework is a software system that calls your code.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/user-code-in-framework.png&quot; alt=&quot;User code running in a framework.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The reality is often more complex, as illustrated by the figure. While a framework will call your code, you can also invoke APIs afforded by the framework.
	&lt;/p&gt;
	&lt;p&gt;
		The point, however, is that &lt;em&gt;user code&lt;/em&gt; is code that you write, while &lt;em&gt;framework code&lt;/em&gt; is code that someone else wrote to develop the framework. The framework starts up first, and at some point in its lifetime, it calls your code.
	&lt;/p&gt;
	&lt;p class=&quot;text-center&quot;&gt;
		&lt;strong&gt;Definition:&lt;/strong&gt; The &lt;em&gt;entry point&lt;/em&gt; is the user code that the framework calls first.
	&lt;/p&gt;
	&lt;p&gt;
		As an example, in ASP.NET Core, the (conventional) &lt;code&gt;Startup&lt;/code&gt; class is the first user code that the framework calls. (If you follow Tomas Petricek's definition to the letter, ASP.NET Core isn't a framework, but a library, because you have to write a &lt;code&gt;Main&lt;/code&gt; method and call &lt;code&gt;WebHost.CreateDefaultBuilder(args).UseStartup&amp;lt;Startup&amp;gt;().Build().Run()&lt;/code&gt;. In reality, though, you're supposed to configure the application from your &lt;code&gt;Startup&lt;/code&gt; class, making it the &lt;em&gt;de facto&lt;/em&gt; entry point.)
	&lt;/p&gt;
	&lt;h3 id=&quot;61e3f212e0e244f18ac998f4b9fbb635&quot;&gt;
		Unit testing endpoints &lt;a href=&quot;#61e3f212e0e244f18ac998f4b9fbb635&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		Most .NET-based unit testing packages are frameworks. There's typically little explicit configuration. Instead, you just write a method and adorn it with an attribute:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;[&lt;span style=&quot;color:#2b91af;&quot;&gt;Fact&lt;/span&gt;]
&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;async&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Task&lt;/span&gt;&amp;nbsp;ReservationSucceeds()
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;repo&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;FakeReservationsRepository&lt;/span&gt;();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;sut&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;ReservationsController&lt;/span&gt;(10,&amp;nbsp;repo);
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;reservation&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Reservation&lt;/span&gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;date:&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTimeOffset&lt;/span&gt;(2018,&amp;nbsp;8,&amp;nbsp;13,&amp;nbsp;16,&amp;nbsp;53,&amp;nbsp;0,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TimeSpan&lt;/span&gt;.FromHours(2)),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;email:&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;mark@example.com&amp;quot;&lt;/span&gt;,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;name:&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Mark&amp;nbsp;Seemann&amp;quot;&lt;/span&gt;,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;quantity:&amp;nbsp;4);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;actual&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;await&lt;/span&gt;&amp;nbsp;sut.Post(reservation);
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Assert&lt;/span&gt;.True(repo.Contains(reservation.Accept()));
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;expectedId&amp;nbsp;=&amp;nbsp;repo.GetId(reservation.Accept());
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;ok&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Assert&lt;/span&gt;.IsAssignableFrom&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;OkActionResult&lt;/span&gt;&amp;gt;(actual);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Assert&lt;/span&gt;.Equal(expectedId,&amp;nbsp;ok.Value);
}
 
[&lt;span style=&quot;color:#2b91af;&quot;&gt;Fact&lt;/span&gt;]
&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;async&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Task&lt;/span&gt;&amp;nbsp;ReservationFails()
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;repo&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;FakeReservationsRepository&lt;/span&gt;();
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;sut&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;ReservationsController&lt;/span&gt;(10,&amp;nbsp;repo);
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;reservation&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Reservation&lt;/span&gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;date:&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;DateTimeOffset&lt;/span&gt;(2018,&amp;nbsp;8,&amp;nbsp;13,&amp;nbsp;16,&amp;nbsp;53,&amp;nbsp;0,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TimeSpan&lt;/span&gt;.FromHours(2)),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;email:&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;mark@example.com&amp;quot;&lt;/span&gt;,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;name:&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Mark&amp;nbsp;Seemann&amp;quot;&lt;/span&gt;,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;quantity:&amp;nbsp;11);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;var&lt;/span&gt;&amp;nbsp;actual&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;await&lt;/span&gt;&amp;nbsp;sut.Post(reservation);
 
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Assert&lt;/span&gt;.False(reservation.IsAccepted);
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Assert&lt;/span&gt;.False(repo.Contains(reservation));
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Assert&lt;/span&gt;.IsAssignableFrom&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;InternalServerErrorActionResult&lt;/span&gt;&amp;gt;(actual);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		With &lt;a href=&quot;https://xunit.net&quot;&gt;xUnit.net&lt;/a&gt;, the attribute is called &lt;code&gt;[Fact]&lt;/code&gt;, but the principle is the same in &lt;a href=&quot;https://nunit.org&quot;&gt;NUnit&lt;/a&gt; and MSTest, only that names are different.
	&lt;/p&gt;
	&lt;p&gt;
		Where's the entry point?
	&lt;/p&gt;
	&lt;p&gt;
		Each test is it's own entry point. The test is (typically) the first user code that the test runner executes. Furthermore, each test runs independently of any other.
	&lt;/p&gt;
	&lt;p&gt;
		For the sake of argument, you could write each test case in a new application, and run all your test applications in parallel. It would be impractical, but it oughtn't change the way you organise the tests. Each test method is, conceptually, a mini-application.
	&lt;/p&gt;
	&lt;p&gt;
		A test method is its own Composition Root; or, more generally, each test has its own Composition Root. In fact, xUnit.net has various extensibility points that enable you to hook into the framework before each test method executes. You can, for example, &lt;a href=&quot;/2010/10/08/AutoDataTheorieswithAutoFixture&quot;&gt;combine a &lt;code&gt;[Theory]&lt;/code&gt; attribute with a custom &lt;code&gt;AutoDataAttribute&lt;/code&gt;&lt;/a&gt;, or you can adorn your tests with a &lt;code&gt;BeforeAfterTestAttribute&lt;/code&gt;. This doesn't change that the test runner will run each test case independently of all the other tests. Those pre-execution hooks play the same role as middleware in real applications.
	&lt;/p&gt;
	&lt;p&gt;
		You can, therefore, consider the &lt;a href=&quot;/2013/06/24/a-heuristic-for-formatting-code-according-to-the-aaa-pattern&quot;&gt;Arrange phase&lt;/a&gt; the Composition Root for each test.
	&lt;/p&gt;
	&lt;p&gt;
		Thus, I don't consider the use of an Auto-mocking Container to be a Service Locator, since &lt;a href=&quot;/2011/08/25/ServiceLocatorrolesvs.mechanics&quot;&gt;its role is to resolve object graphs at the entry point instead of locating services from arbitrary locations in the code base&lt;/a&gt;.
	&lt;/p&gt;
	&lt;h3 id=&quot;200be4483e4b4369abe5912b2a8213c3&quot;&gt;
		Summary &lt;a href=&quot;#200be4483e4b4369abe5912b2a8213c3&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		A Composition Root is located at, or near, the &lt;em&gt;entry point&lt;/em&gt;. An entry point is where &lt;em&gt;user code&lt;/em&gt; is first executed by a framework. Each unit test method constitutes a separate, independent entry point. Therefore, it's consistent with these definitions to use an Auto-mocking Container in a unit test.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/06/17/composition-root-location</guid>
      </item>
    
      <item>
        <title>Tree catamorphism</title>
        <link>https://blog.ploeh.dk/2019/06/10/tree-catamorphism/</link>
        <pubDate>Mon, 10 Jun 2019 09:10:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;The catamorphism for a tree is just a single function with a particular type.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This article is part of an &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;article series about catamorphisms&lt;/a&gt;. A catamorphism is a &lt;a href=&quot;/2017/10/04/from-design-patterns-to-category-theory&quot;&gt;universal abstraction&lt;/a&gt; that describes how to digest a data structure into a potentially more compact value.
	&lt;/p&gt;
	&lt;p&gt;
		This article presents the catamorphism for a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tree_(data_structure)&quot;&gt;tree&lt;/a&gt;, as well as how to identify it. The beginning of this article presents the catamorphism in C#, with examples. The rest of the article describes how to deduce the catamorphism. This part of the article presents my work in &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;. Readers not comfortable with Haskell can just read the first part, and consider the rest of the article as an optional appendix.
	&lt;/p&gt;
	&lt;p&gt;
		A tree is a general-purpose data structure where each node in a tree has an associated value. Each node can have an arbitrary number of branches, including none.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/tree-example.png&quot; alt=&quot;A tree example diagram, with each node containing integers.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The diagram shows an example of a tree of integers. The left branch contains a sub-tree with only a single branch, whereas the right branch contains a sub-tree with three branches. Each of the leaf nodes are trees in their own right, but they all have zero branches.
	&lt;/p&gt;
	&lt;p&gt;
		In this example, each branch at the 'same level' has the same depth, but this isn't required.
	&lt;/p&gt;
	&lt;h3 id=&quot;7d3f657d0c6b443f83eac89370e0c660&quot;&gt;
		C# catamorphism &lt;a href=&quot;#7d3f657d0c6b443f83eac89370e0c660&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As a C# representation of a tree, I'll use the &lt;code&gt;Tree&amp;lt;T&amp;gt;&lt;/code&gt; class from &lt;a href=&quot;/2018/08/06/a-tree-functor&quot;&gt;A Tree functor&lt;/a&gt;. The catamorphism is this instance method on &lt;code&gt;Tree&amp;lt;T&amp;gt;&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;Cata&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IReadOnlyCollection&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;func)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;func(Item,&amp;nbsp;children.Select(c&amp;nbsp;=&amp;gt;&amp;nbsp;c.Cata(func)).ToArray());
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Contrary to previous articles, I didn't call this method &lt;code&gt;Match&lt;/code&gt;, but simply &lt;code&gt;Cata&lt;/code&gt; (for &lt;em&gt;catamorphism&lt;/em&gt;). The reason is that those other methods are called &lt;code&gt;Match&lt;/code&gt; for a particular reason. The data structures for which they are catamorphisms are all &lt;a href=&quot;/2018/05/22/church-encoding&quot;&gt;Church-encoded&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;sum types&lt;/a&gt;. For those types, the &lt;code&gt;Match&lt;/code&gt; methods enable a syntax similar to pattern matching in &lt;a href=&quot;https://fsharp.org&quot;&gt;F#&lt;/a&gt;. That's not the case for &lt;code&gt;Tree&amp;lt;T&amp;gt;&lt;/code&gt;. It's not a sum type, and it isn't Church-encoded.
	&lt;/p&gt;
	&lt;p&gt;
		The method takes a single function as an input argument. This is the first catamorphism in this article series that isn't made up of a pair of some sort. The &lt;a href=&quot;/2019/05/06/boolean-catamorphism&quot;&gt;Boolean catamorphism&lt;/a&gt; is a pair of values, the &lt;a href=&quot;/2019/05/20/maybe-catamorphism&quot;&gt;Maybe catamorphism&lt;/a&gt; is a pair made up of a value and a function, and the &lt;a href=&quot;/2019/06/03/either-catamorphism&quot;&gt;Either catamorphism&lt;/a&gt; is a pair of functions. The tree catamorphism, in contrast, is just a single function.
	&lt;/p&gt;
	&lt;p&gt;
		The first argument to the function is a value of the type &lt;code&gt;T&lt;/code&gt;. This will be an &lt;code&gt;Item&lt;/code&gt; value. The second argument to the function is a finite collection of &lt;code&gt;TResult&lt;/code&gt; values. This may take a little time getting used to, but it's a collection of already reduced sub-trees. When you supply such a function to &lt;code&gt;Cata&lt;/code&gt;, that function must return a single value of the type &lt;code&gt;TResult&lt;/code&gt;. Thus, the function must be able to digest a finite collection of &lt;code&gt;TResult&lt;/code&gt; values, as well as a &lt;code&gt;T&lt;/code&gt; value, to a single &lt;code&gt;TResult&lt;/code&gt; value.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Cata&lt;/code&gt; method accomplishes this by calling &lt;code&gt;func&lt;/code&gt; with the current &lt;code&gt;Item&lt;/code&gt;, as well as by recursively applying itself to each of the sub-trees. Eventually, &lt;code&gt;Cata&lt;/code&gt; will recurse into leaf nodes, which means that &lt;code&gt;children&lt;/code&gt; will be empty. When that happens, the lambda expression inside &lt;code&gt;children.Select&lt;/code&gt; never runs, and recursion stops and unwinds.
	&lt;/p&gt;
	&lt;h3 id=&quot;167ba023ee654db39fb5eb448d35a8df&quot;&gt;
		Examples &lt;a href=&quot;#167ba023ee654db39fb5eb448d35a8df&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can use &lt;code&gt;Cata&lt;/code&gt; to implement most other behaviour you'd like &lt;code&gt;Tree&amp;lt;T&amp;gt;&lt;/code&gt; to have. In &lt;a href=&quot;/2018/08/06/a-tree-functor&quot;&gt;the original article on the Tree functor&lt;/a&gt; you saw an ad-hoc implementation of &lt;code&gt;Select&lt;/code&gt;, but instead, you can derive &lt;code&gt;Select&lt;/code&gt; from &lt;code&gt;Cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;Select&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;selector)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;Cata&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;gt;((x,&amp;nbsp;nodes)&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(selector(x),&amp;nbsp;nodes));
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The lambda expression receives &lt;code&gt;x&lt;/code&gt;, an object of the type &lt;code&gt;T&lt;/code&gt;, as well as &lt;code&gt;nodes&lt;/code&gt;, which is a finite collection of already translated sub-trees. It simply translates &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;selector&lt;/code&gt; and returns a &lt;code&gt;new Tree&amp;lt;TResult&amp;gt;&lt;/code&gt; with the translated value and the already translated &lt;code&gt;nodes&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		This works just as well as the ad-hoc implementation; it passes all the same tests as shown in the previous article.
	&lt;/p&gt;
	&lt;p&gt;
		If you have a tree of numbers, you can add them all together:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;Sum(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;tree)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;tree.Cata&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;((x,&amp;nbsp;xs)&amp;nbsp;=&amp;gt;&amp;nbsp;x&amp;nbsp;+&amp;nbsp;xs.Sum());
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This uses the built-in &lt;a href=&quot;https://docs.microsoft.com/dotnet/api/system.linq.enumerable.sum&quot;&gt;Sum method&lt;/a&gt; for &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; to add all the partly calculated sub-trees together, and then adds the value of the current node. In this and remaining examples, I'll use the tree shown in the above diagram:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;tree&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Create(42,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Create(1337,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(-3)),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Create(7,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(-99),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(100),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(0)));&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can now calculate the sum of all these nodes:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; tree.Sum()
1384&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Another option is to find the maximum value anywhere in a tree:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;Max(&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;tree)
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;tree.Cata&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;((x,&amp;nbsp;xs)&amp;nbsp;=&amp;gt;&amp;nbsp;xs.Any()&amp;nbsp;?&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Math&lt;/span&gt;.Max(x,&amp;nbsp;xs.Max())&amp;nbsp;:&amp;nbsp;x);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This method again utilises one of the LINQ methods available via the .NET base class library: &lt;a href=&quot;https://docs.microsoft.com/dotnet/api/system.linq.enumerable.max&quot;&gt;Max&lt;/a&gt;. It is, however, necessary to first check whether the partially reduced &lt;code&gt;xs&lt;/code&gt; is empty or not, because the &lt;code&gt;Max&lt;/code&gt; extension method on &lt;code&gt;IEnumerable&amp;lt;int&amp;gt;&lt;/code&gt; doesn't know how to deal with an empty collection (it throws an exception). When &lt;code&gt;xs&lt;/code&gt; is empty that implies a leaf node, in which case you can simply return &lt;code&gt;x&lt;/code&gt;; otherwise, you'll first have to use the &lt;code&gt;Max&lt;/code&gt; method on &lt;code&gt;xs&lt;/code&gt; to find the maximum value there, and then use &lt;code&gt;Math.Max&lt;/code&gt; to find the maximum of those two. (I'll here remind the attentive reader that finding the maximum number forms a &lt;a href=&quot;/2017/11/27/semigroups&quot;&gt;semigroup&lt;/a&gt; and that &lt;a href=&quot;/2017/12/11/semigroups-accumulate&quot;&gt;semigroups accumulate&lt;/a&gt; when collections are non-empty. It all fits together. Isn't maths lovely?)
	&lt;/p&gt;
	&lt;p&gt;
		Using the same &lt;code&gt;tree&lt;/code&gt; as before, you can see that this method, too, works as expected:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; tree.Max()
1337&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		So far, these two extension methods are just specialised &lt;em&gt;folds&lt;/em&gt;. In Haskell, &lt;code&gt;Foldable&lt;/code&gt; is a specific type class, and &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are available for all instances. As promised in &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;the introduction to the series&lt;/a&gt;, though, there are some functions on trees that you can't implement using a fold. One of these is to count all the leaf nodes. You can still derive that functionality from the catamorphism, though:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;CountLeaves()
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;Cata&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;((x,&amp;nbsp;xs)&amp;nbsp;=&amp;gt;&amp;nbsp;xs.Any()&amp;nbsp;?&amp;nbsp;xs.Sum()&amp;nbsp;:&amp;nbsp;1);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Like &lt;code&gt;Max&lt;/code&gt;, the lambda expression used to implement &lt;code&gt;CountLeaves&lt;/code&gt; uses &lt;a href=&quot;https://docs.microsoft.com/dotnet/api/system.linq.enumerable.any&quot;&gt;Any&lt;/a&gt; to detect whether or not &lt;code&gt;xs&lt;/code&gt; is empty, which is when &lt;code&gt;Any&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Empty &lt;code&gt;xs&lt;/code&gt; indicates that you've found a leaf node, so return &lt;code&gt;1&lt;/code&gt;. When &lt;code&gt;xs&lt;/code&gt; isn't empty, it contains a collection of &lt;code&gt;1&lt;/code&gt; values - one for each leaf node recursively found; add them together with &lt;code&gt;Sum&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		This also works for the same &lt;code&gt;tree&lt;/code&gt; as before:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; tree.CountLeaves()
4&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can also measure the maximum depth of a tree:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;nbsp;MeasureDepth()
{
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;Cata&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;((x,&amp;nbsp;xs)&amp;nbsp;=&amp;gt;&amp;nbsp;xs.Any()&amp;nbsp;?&amp;nbsp;1&amp;nbsp;+&amp;nbsp;xs.Max()&amp;nbsp;:&amp;nbsp;0);
}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This implementation considers a leaf node to have no depth:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;).MeasureDepth()
0&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This is a discretionary definition; you could also argue that, by definition, a leaf node ought to have a depth of one. If you think so, you'll need to change the &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; in the above &lt;code&gt;MeasureDepth&lt;/code&gt; implementation.
	&lt;/p&gt;
	&lt;p&gt;
		Once more, you can use &lt;code&gt;Any&lt;/code&gt; to detect leaf nodes. Whenever you find a leaf node, you return its depth, which, by definition, is &lt;code&gt;0&lt;/code&gt;. Otherwise, you find the maximum depth already found among &lt;code&gt;xs&lt;/code&gt;, and add &lt;code&gt;1&lt;/code&gt;, because &lt;code&gt;xs&lt;/code&gt; contains the maximum depths of all immediate sub-trees.
	&lt;/p&gt;
	&lt;p&gt;
		Using the same &lt;code&gt;tree&lt;/code&gt; again:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; tree.MeasureDepth()
2&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The above &lt;code&gt;tree&lt;/code&gt; has the same depth for all sub-trees, so here's an example of a tilted tree:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Create(3,
.   &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Create(1,
.     &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(0),
.     &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(0)),
.   &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(0),
.   &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(0),
.   &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Create(2,
.     &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Create(1,
.       &lt;span style=&quot;color:#2b91af;&quot;&gt;Tree&lt;/span&gt;.Leaf(0))))
. .MeasureDepth()
3&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		To make it easier to understand, I've labelled all the leaf nodes with &lt;code&gt;0&lt;/code&gt;, because that's their depth. I've then labelled the other nodes with the maximum number 'under' them, plus one. That's the algorithm used.
	&lt;/p&gt;
	&lt;h3 id=&quot;82e5042d05534db2a67c8f7c37f78419&quot;&gt;
		Tree F-Algebra &lt;a href=&quot;#82e5042d05534db2a67c8f7c37f78419&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As in the &lt;a href=&quot;/2019/06/03/either-catamorphism&quot;&gt;previous article&lt;/a&gt;, I'll use &lt;code&gt;Fix&lt;/code&gt; and &lt;code&gt;cata&lt;/code&gt; as explained in &lt;a href=&quot;https://bartoszmilewski.com&quot;&gt;Bartosz Milewski&lt;/a&gt;'s excellent &lt;a href=&quot;https://bartoszmilewski.com/2017/02/28/f-algebras/&quot;&gt;article on F-Algebras&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		As always, start with the underlying endofunctor. I've taken some inspiration from &lt;code&gt;Tree a&lt;/code&gt; from &lt;code&gt;Data.Tree&lt;/code&gt;, but changed some names:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;TreeF&amp;nbsp;a&amp;nbsp;c&amp;nbsp;=&amp;nbsp;NodeF&amp;nbsp;{&amp;nbsp;nodeValue&amp;nbsp;::&amp;nbsp;a,&amp;nbsp;nodes&amp;nbsp;::&amp;nbsp;ListFix&amp;nbsp;c&amp;nbsp;}&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;TreeF&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;(NodeF&amp;nbsp;x&amp;nbsp;ns)&amp;nbsp;=&amp;nbsp;NodeF&amp;nbsp;x&amp;nbsp;$&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;ns&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Instead of using Haskell's standard list (&lt;code&gt;[]&lt;/code&gt;) for the sub-forest, I've used &lt;code&gt;ListFix&lt;/code&gt; from &lt;a href=&quot;/2019/05/27/list-catamorphism&quot;&gt;the article on list catamorphism&lt;/a&gt;. This should, hopefully, demonstrate how you can build on already established definitions derived from first principles.
	&lt;/p&gt;
	&lt;p&gt;
		As usual, I've called the 'data' type &lt;code&gt;a&lt;/code&gt; and the carrier type &lt;code&gt;c&lt;/code&gt; (for &lt;em&gt;carrier&lt;/em&gt;). The &lt;code&gt;Functor&lt;/code&gt; instance as usual translates the carrier type; the &lt;code&gt;fmap&lt;/code&gt; function has the type &lt;code&gt;(c -&amp;gt; c1) -&amp;gt; TreeF a c -&amp;gt; TreeF a c1&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		As was the case when deducing the recent catamorphisms, Haskell isn't too happy about defining instances for a type like &lt;code&gt;Fix (TreeF a)&lt;/code&gt;. To address that problem, you can introduce a &lt;code&gt;newtype&lt;/code&gt; wrapper:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;newtype&lt;/span&gt;&amp;nbsp;TreeFix&amp;nbsp;a&amp;nbsp;=&amp;nbsp;TreeFix&amp;nbsp;{&amp;nbsp;unTreeFix&amp;nbsp;::&amp;nbsp;Fix&amp;nbsp;(TreeF&amp;nbsp;a)&amp;nbsp;}&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can define &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Monad&lt;/code&gt;, etc. instances for this type without resorting to any funky GHC extensions. Keep in mind that ultimately, the purpose of all this code is just to figure out what the catamorphism looks like. This code isn't intended for actual use.
	&lt;/p&gt;
	&lt;p&gt;
		A pair of helper functions make it easier to define &lt;code&gt;TreeFix&lt;/code&gt; values:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;leafF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;a
leafF&amp;nbsp;x&amp;nbsp;=&amp;nbsp;TreeFix&amp;nbsp;$&amp;nbsp;Fix&amp;nbsp;$&amp;nbsp;NodeF&amp;nbsp;x&amp;nbsp;nilF
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;nodeF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;a
nodeF&amp;nbsp;x&amp;nbsp;=&amp;nbsp;TreeFix&amp;nbsp;.&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;NodeF&amp;nbsp;x&amp;nbsp;.&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;unTreeFix&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		&lt;code&gt;leafF&lt;/code&gt; creates a leaf node:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix List Tree&amp;gt; leafF &quot;ploeh&quot;
TreeFix {unTreeFix = Fix (NodeF &quot;ploeh&quot; (ListFix (Fix NilF)))}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		&lt;code&gt;nodeF&lt;/code&gt; is a helper function to create a non-leaf node:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix List Tree&amp;gt; nodeF 4 (consF (leafF 9) nilF)
TreeFix {unTreeFix =
  Fix (NodeF 4 (ListFix (Fix (ConsF (Fix (NodeF 9 (ListFix (Fix NilF)))) (Fix NilF)))))}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Even with helper functions, construction of &lt;code&gt;TreeFix&lt;/code&gt; values is cumbersome, but keep in mind that the code shown here isn't meant to be used in practice. The goal is only to deduce catamorphisms from more basic universal abstractions, and you now have all you need to do that.
	&lt;/p&gt;
	&lt;h3 id=&quot;ca5669298d814809a3f0d4b0422b860f&quot;&gt;
		Haskell catamorphism &lt;a href=&quot;#ca5669298d814809a3f0d4b0422b860f&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		At this point, you have two out of three elements of an F-Algebra. You have an endofunctor (&lt;code&gt;TreeF a&lt;/code&gt;), and an object &lt;code&gt;c&lt;/code&gt;, but you still need to find a morphism &lt;code&gt;TreeF a c -&amp;gt; c&lt;/code&gt;. Notice that the algebra you have to find is the function that reduces the functor to its &lt;em&gt;carrier type&lt;/em&gt; &lt;code&gt;c&lt;/code&gt;, not the 'data type' &lt;code&gt;a&lt;/code&gt;. This takes some time to get used to, but that's how catamorphisms work. This doesn't mean, however, that you get to ignore &lt;code&gt;a&lt;/code&gt;, as you'll see.
	&lt;/p&gt;
	&lt;p&gt;
		As in the previous articles, start by writing a function that will become the catamorphism, based on &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;treeF&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unTreeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;(NodeF&amp;nbsp;x&amp;nbsp;ns)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While this compiles, with its &lt;code&gt;undefined&lt;/code&gt; implementation of &lt;code&gt;alg&lt;/code&gt;, it obviously doesn't do anything useful. I find, however, that it helps me think. How can you return a value of the type &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;alg&lt;/code&gt;? You could pass a function argument to the &lt;code&gt;treeF&lt;/code&gt; function and use it with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;ns&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;treeF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;(a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
treeF&amp;nbsp;f&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unTreeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;(NodeF&amp;nbsp;x&amp;nbsp;ns)&amp;nbsp;=&amp;nbsp;f&amp;nbsp;x&amp;nbsp;ns&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This works. Since &lt;code&gt;cata&lt;/code&gt; has the type &lt;code&gt;Functor f =&amp;gt; (f a -&amp;gt; a) -&amp;gt; Fix f -&amp;gt; a&lt;/code&gt;, that means that &lt;code&gt;alg&lt;/code&gt; has the type &lt;code&gt;f a -&amp;gt; a&lt;/code&gt;. In the case of &lt;code&gt;TreeF&lt;/code&gt;, the compiler infers that the &lt;code&gt;alg&lt;/code&gt; function has the type &lt;code&gt;TreeF a c -&amp;gt; c&lt;/code&gt;, which is just what you need!
	&lt;/p&gt;
	&lt;p&gt;
		You can now see what the carrier type &lt;code&gt;c&lt;/code&gt; is for. It's the type that the algebra extracts, and thus the type that the catamorphism returns.
	&lt;/p&gt;
	&lt;p&gt;
		This, then, is the catamorphism for a tree. So far in this article series, all previous catamorphisms have been pairs, but this one is just a single function. It's still not the only possible catamorphism, since you could trivially flip the arguments to &lt;code&gt;f&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		I've chosen the representation shown here because it's isomorphic to the &lt;code&gt;foldTree&lt;/code&gt; function from Haskell's built-in &lt;code&gt;Data.Tree&lt;/code&gt; module, which explicitly documents that the function &quot;is also known as the catamorphism on trees.&quot; &lt;code&gt;foldTree&lt;/code&gt; is defined using Haskell's standard list type (&lt;code&gt;[]&lt;/code&gt;), so the type is simpler: &lt;code&gt;(a -&amp;gt; [b] -&amp;gt; b) -&amp;gt; Tree a -&amp;gt; b&lt;/code&gt;. The two representations of trees, &lt;code&gt;TreeFix&lt;/code&gt; and &lt;code&gt;Tree&lt;/code&gt; are, however, isomorphic, so &lt;code&gt;foldTree&lt;/code&gt; is equivalent to &lt;code&gt;treeF&lt;/code&gt;. Notice how both of these functions are also equivalent to the above C# &lt;code&gt;Cata&lt;/code&gt; method.
	&lt;/p&gt;
	&lt;h3 id=&quot;8647c7bd03aa4d4b8a01a8252058830f&quot;&gt;
		Basis &lt;a href=&quot;#8647c7bd03aa4d4b8a01a8252058830f&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can implement most other useful functionality with &lt;code&gt;treeF&lt;/code&gt;. Here's the &lt;code&gt;Functor&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;=&amp;nbsp;treeF&amp;nbsp;(nodeF&amp;nbsp;.&amp;nbsp;f)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		&lt;code&gt;nodeF . f&lt;/code&gt; is just the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tacit_programming&quot;&gt;point-free&lt;/a&gt; version of &lt;code&gt;\x ns -&amp;gt; nodeF (f x) ns&lt;/code&gt;, which follows the exact same implementation logic as the above C# &lt;code&gt;Select&lt;/code&gt; implementation.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Applicative&lt;/code&gt; instance is, I'm afraid, the most complex code you've seen so far in this article series:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Applicative&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;pure&amp;nbsp;=&amp;nbsp;leafF
&amp;nbsp;&amp;nbsp;ft&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;xt&amp;nbsp;=&amp;nbsp;treeF&amp;nbsp;(\f&amp;nbsp;ts&amp;nbsp;-&amp;gt;&amp;nbsp;addNodes&amp;nbsp;ts&amp;nbsp;$&amp;nbsp;f&amp;nbsp;&amp;lt;$&amp;gt;&amp;nbsp;xt)&amp;nbsp;ft
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;addNodes&amp;nbsp;ns&amp;nbsp;(TreeFix&amp;nbsp;(Fix&amp;nbsp;(NodeF&amp;nbsp;x&amp;nbsp;xs)))&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TreeFix&amp;nbsp;(Fix&amp;nbsp;(NodeF&amp;nbsp;x&amp;nbsp;(xs&amp;nbsp;&amp;lt;&amp;gt;&amp;nbsp;(unTreeFix&amp;nbsp;&amp;lt;$&amp;gt;&amp;nbsp;ns))))&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I'd be surprised if it's impossible to make this terser, but I thought that it was just complicated enough that I needed to make one of the steps explicit. The &lt;code&gt;addNodes&lt;/code&gt; helper function has the type &lt;code&gt;ListFix (TreeFix a) -&amp;gt; TreeFix a -&amp;gt; TreeFix a&lt;/code&gt;, and it adds a list of sub-trees to the top node of a tree. It looks worse than it is, but it really just peels off the wrappers (&lt;code&gt;TreeFix&lt;/code&gt;, &lt;code&gt;Fix&lt;/code&gt;, and &lt;code&gt;NodeF&lt;/code&gt;) to access the data (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;xs&lt;/code&gt;) of the top node. It then concatenates &lt;code&gt;xs&lt;/code&gt; with &lt;code&gt;ns&lt;/code&gt;, and puts all the wrappers back on.
	&lt;/p&gt;
	&lt;p&gt;
		I have to admit, though, that the &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Monad&lt;/code&gt; instance in general are mind-binding to me. The &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; operation, particularly, takes a &lt;em&gt;tree of functions&lt;/em&gt; and has to combine it with a &lt;em&gt;tree of values&lt;/em&gt;. What does that even mean? How does one do that?
	&lt;/p&gt;
	&lt;p&gt;
		Like the above, apparently. I took the &lt;code&gt;Applicative&lt;/code&gt; behaviour from &lt;code&gt;Data.Tree&lt;/code&gt; and made sure that my implementation is isomorphic. I even have a property to make 'sure' that's the case:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;testProperty&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Applicative&amp;nbsp;behaves&amp;nbsp;like&amp;nbsp;Data.Tree&amp;quot;&lt;/span&gt;&amp;nbsp;$&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;do&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;xt&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Integer&lt;/span&gt;&amp;nbsp;&amp;lt;-&amp;nbsp;fromTree&amp;nbsp;&amp;lt;$&amp;gt;&amp;nbsp;resize&amp;nbsp;10&amp;nbsp;arbitrary
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;ft&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Integer&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;String&lt;/span&gt;)&amp;nbsp;&amp;lt;-&amp;nbsp;fromTree&amp;nbsp;&amp;lt;$&amp;gt;&amp;nbsp;resize&amp;nbsp;5&amp;nbsp;arbitrary
 
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;let&lt;/span&gt;&amp;nbsp;actual&amp;nbsp;=&amp;nbsp;ft&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;xt
 
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;let&lt;/span&gt;&amp;nbsp;expected&amp;nbsp;=&amp;nbsp;toTree&amp;nbsp;ft&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;toTree&amp;nbsp;xt
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;$&amp;nbsp;expected&amp;nbsp;===&amp;nbsp;toTree&amp;nbsp;actual&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Monad&lt;/code&gt; instance looks similar to the &lt;code&gt;Applicative&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Monad&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;t&amp;nbsp;&amp;gt;&amp;gt;=&amp;nbsp;f&amp;nbsp;=&amp;nbsp;treeF&amp;nbsp;(\x&amp;nbsp;ns&amp;nbsp;-&amp;gt;&amp;nbsp;addNodes&amp;nbsp;ns&amp;nbsp;$&amp;nbsp;f&amp;nbsp;x)&amp;nbsp;t
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;addNodes&amp;nbsp;ns&amp;nbsp;(TreeFix&amp;nbsp;(Fix&amp;nbsp;(NodeF&amp;nbsp;x&amp;nbsp;xs)))&amp;nbsp;=
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TreeFix&amp;nbsp;(Fix&amp;nbsp;(NodeF&amp;nbsp;x&amp;nbsp;(xs&amp;nbsp;&amp;lt;&amp;gt;&amp;nbsp;(unTreeFix&amp;nbsp;&amp;lt;$&amp;gt;&amp;nbsp;ns))))&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;addNodes&lt;/code&gt; helper function is the same as for &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, so you may wonder why I didn't extract that as a separate, reusable function. I decided, however, to apply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)&quot;&gt;rule of three&lt;/a&gt;, and since, ultimately, &lt;code&gt;addNodes&lt;/code&gt; appear only twice, I left them as the implementation details they are.
	&lt;/p&gt;
	&lt;p&gt;
		Fortunately, the &lt;code&gt;Foldable&lt;/code&gt; instance is easier on the eyes:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Foldable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;foldMap&amp;nbsp;f&amp;nbsp;=&amp;nbsp;treeF&amp;nbsp;(\x&amp;nbsp;xs&amp;nbsp;-&amp;gt;&amp;nbsp;f&amp;nbsp;x&amp;nbsp;&amp;lt;&amp;gt;&amp;nbsp;fold&amp;nbsp;xs)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Since &lt;code&gt;f&lt;/code&gt; is a function of the type &lt;code&gt;a -&amp;gt; m&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;Monoid&lt;/code&gt; instance, you can use &lt;code&gt;fold&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; to accumulate everything to a single &lt;code&gt;m&lt;/code&gt; value.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Traversable&lt;/code&gt; instance is similarly terse:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Traversable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;sequenceA&amp;nbsp;=&amp;nbsp;treeF&amp;nbsp;(\x&amp;nbsp;ns&amp;nbsp;-&amp;gt;&amp;nbsp;nodeF&amp;nbsp;&amp;lt;$&amp;gt;&amp;nbsp;x&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;sequenceA&amp;nbsp;ns)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Finally, you can implement conversions to and from the &lt;code&gt;Tree&lt;/code&gt; type from &lt;code&gt;Data.Tree&lt;/code&gt;, using &lt;code&gt;ana&lt;/code&gt; as the dual of &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;toTree&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Tree&lt;/span&gt;&amp;nbsp;a
toTree&amp;nbsp;=&amp;nbsp;treeF&amp;nbsp;(\x&amp;nbsp;ns&amp;nbsp;-&amp;gt;&amp;nbsp;Node&amp;nbsp;x&amp;nbsp;$&amp;nbsp;toList&amp;nbsp;ns)
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;fromTree&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Tree&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;a
fromTree&amp;nbsp;=&amp;nbsp;TreeFix&amp;nbsp;.&amp;nbsp;ana&amp;nbsp;coalg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;coalg&amp;nbsp;(Node&amp;nbsp;x&amp;nbsp;ns)&amp;nbsp;=&amp;nbsp;NodeF&amp;nbsp;x&amp;nbsp;(fromList&amp;nbsp;ns)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This demonstrates that &lt;code&gt;TreeFix&lt;/code&gt; is isomorphic to &lt;code&gt;Tree&lt;/code&gt;, which again establishes that &lt;code&gt;treeF&lt;/code&gt; and &lt;code&gt;foldTree&lt;/code&gt; are equivalent.
	&lt;/p&gt;
	&lt;h3 id=&quot;7180d37efb404a70b707f8c9b8639a35&quot;&gt;
		Relationships &lt;a href=&quot;#7180d37efb404a70b707f8c9b8639a35&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		In this series, you've seen various examples of catamorphisms of structures that have no folds, catamorphisms that coincide with folds, and catamorphisms that are more general than the fold. The introduction to the series included this diagram:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/catamorphism-and-fold-relations.png&quot; alt=&quot;Catamorphisms and folds as sets, for various sum types.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;a href=&quot;/2019/06/03/either-catamorphism&quot;&gt;Either catamorphism&lt;/a&gt; is another example of a catamorphism that is more general than the fold, but that one turned out to be identical to the &lt;em&gt;bifold&lt;/em&gt;. That's not the case here, because &lt;code&gt;TreeFix&lt;/code&gt; isn't a &lt;code&gt;Bifoldable&lt;/code&gt; instance at all.
	&lt;/p&gt;
	&lt;p&gt;
		There are operations on trees that you can implement with a fold, but some that you can't. Consider the tree in shown in the diagram at the beginning of the article. This is also the tree that the above C# examples use. In Haskell, using &lt;code&gt;TreeFix&lt;/code&gt;, you can define that tree like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;tree&amp;nbsp;=
&amp;nbsp;&amp;nbsp;nodeF&amp;nbsp;42
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(consF&amp;nbsp;(nodeF&amp;nbsp;1337
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(consF&amp;nbsp;(leafF&amp;nbsp;(-3))&amp;nbsp;nilF))&amp;nbsp;$
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;consF&amp;nbsp;(nodeF&amp;nbsp;7
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(consF&amp;nbsp;(leafF&amp;nbsp;(-99))&amp;nbsp;$
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;consF&amp;nbsp;(leafF&amp;nbsp;100)&amp;nbsp;$
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;consF&amp;nbsp;(leafF&amp;nbsp;0)&amp;nbsp;nilF))
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nilF)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Yes, that almost looks like some Lisp dialect...
	&lt;/p&gt;
	&lt;p&gt;
		Since &lt;code&gt;TreeFix&lt;/code&gt; is &lt;code&gt;Foldable&lt;/code&gt;, and that type class already comes with &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;maximum&lt;/code&gt; functions, no further work is required to repeat the first two of the above C# examples:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;*Tree Fix List Tree&amp;gt; sum tree
1384
*Tree Fix List Tree&amp;gt; maximum tree
1337&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Counting leaves, or measuring the depth of a tree, on the other hand, is impossible with the &lt;code&gt;Foldable&lt;/code&gt; instance, but can be implemented using the catamorphism:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;countLeaves&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Num&lt;/span&gt;&amp;nbsp;n&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;n
countLeaves&amp;nbsp;=&amp;nbsp;treeF&amp;nbsp;(\_&amp;nbsp;xs&amp;nbsp;-&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;null&lt;/span&gt;&amp;nbsp;xs&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;then&lt;/span&gt;&amp;nbsp;1&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;else&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;sum&lt;/span&gt;&amp;nbsp;xs)
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;treeDepth&lt;/span&gt;&amp;nbsp;::&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;Ord&lt;/span&gt;&amp;nbsp;n,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Num&lt;/span&gt;&amp;nbsp;n)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;=&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;TreeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;n
treeDepth&amp;nbsp;=&amp;nbsp;treeF&amp;nbsp;(\_&amp;nbsp;xs&amp;nbsp;-&amp;gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;if&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;null&lt;/span&gt;&amp;nbsp;xs&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;then&lt;/span&gt;&amp;nbsp;0&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;else&lt;/span&gt;&amp;nbsp;1&amp;nbsp;+&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;maximum&lt;/span&gt;&amp;nbsp;xs)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The reasoning is the same as already explained in the above C# examples. The functions also produce the same results:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;*Tree Fix List Tree&amp;gt; countLeaves tree
4
*Tree Fix List Tree&amp;gt; treeDepth tree
2&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This, hopefully, illustrates that the catamorphism is more capable, and that the fold is just a (list-biased) specialisation.
	&lt;/p&gt;
	&lt;h3 id=&quot;66f69ba33cef4ed58d01f1f0bafef14a&quot;&gt;
		Summary &lt;a href=&quot;#66f69ba33cef4ed58d01f1f0bafef14a&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The catamorphism for a tree is just a single function, which is recursively evaluated. It enables you to translate, traverse, and reduce trees in many interesting ways.
	&lt;/p&gt;
	&lt;p&gt;
		You can use the catamorphism to implement a (list-biased) fold, including enumerating all nodes as a flat list, but there are operations (such as counting leaves) that you can implement with the catamorphism, but not with the fold.
	&lt;/p&gt;
	&lt;p&gt;
		This article series has so far covered progressively more complex data structures. The first examples (&lt;a href=&quot;/2019/05/06/boolean-catamorphism&quot;&gt;Boolean catamorphism&lt;/a&gt; and &lt;a href=&quot;/2019/05/13/peano-catamorphism&quot;&gt;Peano catamorphism&lt;/a&gt;) were neither &lt;a href=&quot;/2018/03/22/functors&quot;&gt;functors&lt;/a&gt;, &lt;a href=&quot;/2018/10/01/applicative-functors&quot;&gt;applicatives&lt;/a&gt;, nor monads. All subsequent examples, on the other hand, are all of these, and more. The next example presents a functor that's neither applicative nor monad, yet still foldable. Obviously, what functionality it offers is still based on a catamorphism.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;strong&gt;Next:&lt;/strong&gt; &lt;a href=&quot;/2019/06/24/full-binary-tree-catamorphism&quot;&gt;Full binary tree catamorphism&lt;/a&gt;.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/06/10/tree-catamorphism</guid>
      </item>
    
      <item>
        <title>Either catamorphism</title>
        <link>https://blog.ploeh.dk/2019/06/03/either-catamorphism/</link>
        <pubDate>Mon, 03 Jun 2019 06:05:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;The catamorphism for Either is a generalisation of its fold. The catamorphism enables operations not available via fold.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This article is part of an &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;article series about catamorphisms&lt;/a&gt;. A catamorphism is a &lt;a href=&quot;/2017/10/04/from-design-patterns-to-category-theory&quot;&gt;universal abstraction&lt;/a&gt; that describes how to digest a data structure into a potentially more compact value.
	&lt;/p&gt;
	&lt;p&gt;
		This article presents the catamorphism for &lt;a href=&quot;/2018/06/11/church-encoded-either&quot;&gt;Either&lt;/a&gt; (also known as &lt;em&gt;Result&lt;/em&gt;), as well as how to identify it. The beginning of this article presents the catamorphism in C#, with examples. The rest of the article describes how to deduce the catamorphism. This part of the article presents my work in &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;. Readers not comfortable with Haskell can just read the first part, and consider the rest of the article as an optional appendix.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;em&gt;Either&lt;/em&gt; is a &lt;a href=&quot;https://bartoszmilewski.com/2014/01/14/functors-are-containers&quot;&gt;data container&lt;/a&gt; that models two mutually exclusive results. It's often used to return values that may be either correct (&lt;em&gt;right&lt;/em&gt;), or incorrect (&lt;em&gt;left&lt;/em&gt;). In statically typed functional programming with a preference for total functions, Either offers a saner, more reasonable way to model success and error results than throwing exceptions.
	&lt;/p&gt;
	&lt;h3 id=&quot;d8214c38aac04ee7b80b9352d57d3bd1&quot;&gt;
		C# catamorphism &lt;a href=&quot;#d8214c38aac04ee7b80b9352d57d3bd1&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		This article uses &lt;a href=&quot;/2018/06/11/church-encoded-either&quot;&gt;the Church encoding of Either&lt;/a&gt;. The catamorphism for Either is the &lt;code&gt;Match&lt;/code&gt; method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;nbsp;Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;L&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;onLeft,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;R&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;nbsp;onRight);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Until this article, all previous catamorphisms have been a pair made from an initial value and a function. The Either catamorphism is a generalisation, since it's a pair of functions. One function handles the case where there's a &lt;em&gt;left&lt;/em&gt; value, and the other function handles the case where there's a &lt;em&gt;right&lt;/em&gt; value. Both functions must return the same, unifying type, which is often a string or something similar that can be shown in a user interface:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IEither&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TimeSpan&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;e&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Left&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TimeSpan&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;TimeSpan&lt;/span&gt;.FromMinutes(3));
&amp;gt; e.Match(ts&amp;nbsp;=&amp;gt;&amp;nbsp;ts.ToString(),&amp;nbsp;i&amp;nbsp;=&amp;gt;&amp;nbsp;i.ToString())
&quot;00:03:00&quot;
&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IEither&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TimeSpan&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;e&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Right&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TimeSpan&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;(42);
&amp;gt; e.Match(ts&amp;nbsp;=&amp;gt;&amp;nbsp;ts.ToString(),&amp;nbsp;i&amp;nbsp;=&amp;gt;&amp;nbsp;i.ToString())
&quot;42&quot;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You'll often see examples like the above that turns both left and right cases into strings or something that can be represented as a unifying response type, but this is in no way required. If you can come up with a unifying type, you can convert both cases to that type:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IEither&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Guid&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;nbsp;e&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Left&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Guid&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Guid&lt;/span&gt;.NewGuid());
&amp;gt; e.Match(g&amp;nbsp;=&amp;gt;&amp;nbsp;g.ToString().Count(c&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;c),&amp;nbsp;s&amp;nbsp;=&amp;gt;&amp;nbsp;s.Length)
12
&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IEither&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Guid&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;nbsp;e&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Right&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Guid&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;string&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;);
&amp;gt; e.Match(g&amp;nbsp;=&amp;gt;&amp;nbsp;g.ToString().Count(c&amp;nbsp;=&amp;gt;&amp;nbsp;&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&amp;nbsp;&amp;lt;=&amp;nbsp;c),&amp;nbsp;s&amp;nbsp;=&amp;gt;&amp;nbsp;s.Length)
3&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In the two above examples, you use two different functions that both reduce respectively &lt;code&gt;Guid&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; values to a number. The function that turns &lt;code&gt;Guid&lt;/code&gt; values into a number counts how many of the hexadecimal digits that are greater than or equal to A (10). The other function simply returns the length of the &lt;code&gt;string&lt;/code&gt;, if it's there. That example makes little sense, but the &lt;code&gt;Match&lt;/code&gt; method doesn't care about that.
	&lt;/p&gt;
	&lt;p&gt;
		In practical use, Either is often used for error handling. The &lt;a href=&quot;/2018/06/11/church-encoded-either&quot;&gt;article on the Church encoding of Either&lt;/a&gt; contains an example.
	&lt;/p&gt;
	&lt;h3 id=&quot;99e1027823114e95bebf81c08d35779f&quot;&gt;
		Either F-Algebra &lt;a href=&quot;#99e1027823114e95bebf81c08d35779f&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As in the &lt;a href=&quot;/2019/05/27/list-catamorphism&quot;&gt;previous article&lt;/a&gt;, I'll use &lt;code&gt;Fix&lt;/code&gt; and &lt;code&gt;cata&lt;/code&gt; as explained in &lt;a href=&quot;https://bartoszmilewski.com&quot;&gt;Bartosz Milewski&lt;/a&gt;'s excellent &lt;a href=&quot;https://bartoszmilewski.com/2017/02/28/f-algebras/&quot;&gt;article on F-Algebras&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		While F-Algebras and fixed points are mostly used for recursive data structures, you can also define an F-Algebra for a non-recursive data structure. You already saw an example of that in the articles about &lt;a href=&quot;/2019/05/06/boolean-catamorphism&quot;&gt;Boolean catamorphism&lt;/a&gt; and &lt;a href=&quot;/2019/05/20/maybe-catamorphism&quot;&gt;Maybe catamorphism&lt;/a&gt;. The difference between e.g. Maybe values and Either is that both cases of Either carry a value. You can model this as a &lt;code&gt;Functor&lt;/code&gt; with both a carrier type and two type arguments for the data that Either may contain:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;EitherF&amp;nbsp;l&amp;nbsp;r&amp;nbsp;c&amp;nbsp;=&amp;nbsp;LeftF&amp;nbsp;l&amp;nbsp;|&amp;nbsp;RightF&amp;nbsp;r&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;EitherF&lt;/span&gt;&amp;nbsp;l&amp;nbsp;r)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;&amp;nbsp;(LeftF&amp;nbsp;l)&amp;nbsp;=&amp;nbsp;LeftF&amp;nbsp;l
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;(RightF&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;RightF&amp;nbsp;r&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I chose to call the 'data types' &lt;code&gt;l&lt;/code&gt; (for &lt;em&gt;left&lt;/em&gt;) and &lt;code&gt;r&lt;/code&gt; (for &lt;em&gt;right&lt;/em&gt;), and the carrier type &lt;code&gt;c&lt;/code&gt; (for &lt;em&gt;carrier&lt;/em&gt;). As was also the case with &lt;code&gt;BoolF&lt;/code&gt; and &lt;code&gt;MaybeF&lt;/code&gt;, the &lt;code&gt;Functor&lt;/code&gt; instance ignores the map function because the carrier type is missing from both the &lt;code&gt;LeftF&lt;/code&gt; case and the &lt;code&gt;RightF&lt;/code&gt; case. Like the &lt;code&gt;Functor&lt;/code&gt; instances for &lt;code&gt;BoolF&lt;/code&gt; and &lt;code&gt;MaybeF&lt;/code&gt;, it'd seem that nothing happens, but at the type level, this is still a translation from &lt;code&gt;EitherF l r c&lt;/code&gt; to &lt;code&gt;EitherF l r c1&lt;/code&gt;. Not much of a function, perhaps, but definitely an &lt;em&gt;endofunctor&lt;/em&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		As was also the case when deducing the Maybe and List catamorphisms, Haskell isn't too happy about defining instances for a type like &lt;code&gt;Fix (EitherF l r)&lt;/code&gt;. To address that problem, you can introduce a &lt;code&gt;newtype&lt;/code&gt; wrapper:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;newtype&lt;/span&gt;&amp;nbsp;EitherFix&amp;nbsp;l&amp;nbsp;r&amp;nbsp;=&amp;nbsp;EitherFix&amp;nbsp;{&amp;nbsp;unEitherFix&amp;nbsp;::&amp;nbsp;Fix&amp;nbsp;(EitherF&amp;nbsp;l&amp;nbsp;r)&amp;nbsp;}&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can define &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Monad&lt;/code&gt;, etc. instances for this type without resorting to any funky GHC extensions. Keep in mind that ultimately, the purpose of all this code is just to figure out what the catamorphism looks like. This code isn't intended for actual use.
	&lt;/p&gt;
	&lt;p&gt;
		A pair of helper functions make it easier to define &lt;code&gt;EitherFix&lt;/code&gt; values:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;leftF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;l&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l&amp;nbsp;r
leftF&amp;nbsp;=&amp;nbsp;EitherFix&amp;nbsp;.&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;LeftF
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;rightF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;r&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l&amp;nbsp;r
rightF&amp;nbsp;=&amp;nbsp;EitherFix&amp;nbsp;.&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;RightF&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		With those functions, you can create &lt;code&gt;EitherFix&lt;/code&gt; values:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Data.UUID Data.UUID.V4 Fix Either&amp;gt; leftF &amp;lt;$&amp;gt; nextRandom
EitherFix {unEitherFix = Fix (LeftF e65378c2-0d6e-47e0-8bcb-7cc29d185fad)}
Prelude Data.UUID Data.UUID.V4 Fix Either&amp;gt; rightF &quot;foo&quot;
EitherFix {unEitherFix = Fix (RightF &quot;foo&quot;)}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		That's all you need to identify the catamorphism.
	&lt;/p&gt;
	&lt;h3 id=&quot;67d13d05a8564f3481e181d0c32b3165&quot;&gt;
		Haskell catamorphism &lt;a href=&quot;#67d13d05a8564f3481e181d0c32b3165&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		At this point, you have two out of three elements of an F-Algebra. You have an endofunctor (&lt;code&gt;EitherF l r&lt;/code&gt;), and an object &lt;code&gt;c&lt;/code&gt;, but you still need to find a morphism &lt;code&gt;EitherF l r c -&amp;gt; c&lt;/code&gt;. Notice that the algebra you have to find is the function that reduces the functor to its &lt;em&gt;carrier type&lt;/em&gt; &lt;code&gt;c&lt;/code&gt;, not the 'data types' &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;. This takes some time to get used to, but that's how catamorphisms work. This doesn't mean, however, that you get to ignore &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;, as you'll see.
	&lt;/p&gt;
	&lt;p&gt;
		As in the previous articles, start by writing a function that will become the catamorphism, based on &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;eitherF&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unEitherFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;(LeftF&amp;nbsp;l)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(RightF&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While this compiles, with its &lt;code&gt;undefined&lt;/code&gt; implementations, it obviously doesn't do anything useful. I find, however, that it helps me think. How can you return a value of the type &lt;code&gt;c&lt;/code&gt; from the &lt;code&gt;LeftF&lt;/code&gt; case? You could pass an argument to the &lt;code&gt;eitherF&lt;/code&gt; function:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;eitherF&amp;nbsp;fl&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unEitherFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;(LeftF&amp;nbsp;l)&amp;nbsp;=&amp;nbsp;fl&amp;nbsp;l
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(RightF&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While you could, technically, pass an argument of the type &lt;code&gt;c&lt;/code&gt; to &lt;code&gt;eitherF&lt;/code&gt; and then return that value from the &lt;code&gt;LeftF&lt;/code&gt; case, that would mean that you would ignore the &lt;code&gt;l&lt;/code&gt; value. This would be incorrect, so instead, make the argument a function and call it with &lt;code&gt;l&lt;/code&gt;. Likewise, you can deal with the &lt;code&gt;RightF&lt;/code&gt; case in the same way:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;eitherF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;(l&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;(r&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l&amp;nbsp;r&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
eitherF&amp;nbsp;fl&amp;nbsp;fr&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unEitherFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;(LeftF&amp;nbsp;l)&amp;nbsp;=&amp;nbsp;fl&amp;nbsp;l
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(RightF&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;fr&amp;nbsp;r&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This works. Since &lt;code&gt;cata&lt;/code&gt; has the type &lt;code&gt;Functor f =&amp;gt; (f a -&amp;gt; a) -&amp;gt; Fix f -&amp;gt; a&lt;/code&gt;, that means that &lt;code&gt;alg&lt;/code&gt; has the type &lt;code&gt;f a -&amp;gt; a&lt;/code&gt;. In the case of &lt;code&gt;EitherF&lt;/code&gt;, the compiler infers that the &lt;code&gt;alg&lt;/code&gt; function has the type &lt;code&gt;EitherF l r c -&amp;gt; c&lt;/code&gt;, which is just what you need!
	&lt;/p&gt;
	&lt;p&gt;
		You can now see what the carrier type &lt;code&gt;c&lt;/code&gt; is for. It's the type that the algebra extracts, and thus the type that the catamorphism returns.
	&lt;/p&gt;
	&lt;p&gt;
		This, then, is the catamorphism for Either. As has been consistent so far, it's a pair, but now made from two functions. As you've seen repeatedly, this isn't the only possible catamorphism, since you can, for example, trivially flip the arguments to &lt;code&gt;eitherF&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		I've chosen the representation shown here because it's isomorphic to the &lt;code&gt;either&lt;/code&gt; function from Haskell's built-in &lt;code&gt;Data.Either&lt;/code&gt; module, which calls the function the &quot;Case analysis for the &lt;code&gt;Either&lt;/code&gt; type&quot;. Both of these functions (&lt;code&gt;eitherF&lt;/code&gt; and &lt;code&gt;either&lt;/code&gt;) are equivalent to the above C# &lt;code&gt;Match&lt;/code&gt; method.
	&lt;/p&gt;
	&lt;h3 id=&quot;77731d63c79543b0994c06721521b6f3&quot;&gt;
		Basis &lt;a href=&quot;#77731d63c79543b0994c06721521b6f3&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can implement most other useful functionality with &lt;code&gt;eitherF&lt;/code&gt;. Here's the &lt;code&gt;Bifunctor&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Bifunctor&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;bimap&amp;nbsp;f&amp;nbsp;s&amp;nbsp;=&amp;nbsp;eitherF&amp;nbsp;(leftF&amp;nbsp;.&amp;nbsp;f)&amp;nbsp;(rightF&amp;nbsp;.&amp;nbsp;s)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		From that instance, the &lt;code&gt;Functor&lt;/code&gt; instance trivially follows:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;=&amp;nbsp;second&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		On top of &lt;code&gt;Functor&lt;/code&gt; you can add &lt;code&gt;Applicative&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Applicative&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;pure&amp;nbsp;=&amp;nbsp;rightF
&amp;nbsp;&amp;nbsp;f&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;x&amp;nbsp;=&amp;nbsp;eitherF&amp;nbsp;leftF&amp;nbsp;(&amp;lt;$&amp;gt;&amp;nbsp;x)&amp;nbsp;f&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Notice that the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; implementation is similar to to the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; implementation for &lt;code&gt;MaybeFix&lt;/code&gt;. The same is the case for the &lt;code&gt;Monad&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Monad&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;gt;&amp;gt;=&amp;nbsp;f&amp;nbsp;=&amp;nbsp;eitherF&amp;nbsp;leftF&amp;nbsp;f&amp;nbsp;x&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Not only is &lt;code&gt;EitherFix&lt;/code&gt; &lt;code&gt;Foldable&lt;/code&gt;, it's &lt;code&gt;Bifoldable&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Bifoldable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;bifoldMap&amp;nbsp;=&amp;nbsp;eitherF&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Notice, interestingly, that &lt;code&gt;bifoldMap&lt;/code&gt; is identical to &lt;code&gt;eitherF&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Bifoldable&lt;/code&gt; instance enables you to trivially implement the &lt;code&gt;Foldable&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Foldable&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;foldMap&amp;nbsp;=&amp;nbsp;bifoldMap&amp;nbsp;mempty&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You may find the presence of &lt;code&gt;mempty&lt;/code&gt; puzzling, since &lt;code&gt;bifoldMap&lt;/code&gt; (or &lt;code&gt;eitherF&lt;/code&gt;; they're identical) takes as arguments two functions. Is &lt;code&gt;mempty&lt;/code&gt; a function?
	&lt;/p&gt;
	&lt;p&gt;
		Yes, &lt;code&gt;mempty&lt;/code&gt; can be a function. Here, it is. There's a &lt;code&gt;Monoid&lt;/code&gt; instance for any function &lt;code&gt;a -&amp;gt; m&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is a &lt;code&gt;Monoid&lt;/code&gt; instance, and &lt;code&gt;mempty&lt;/code&gt; is the identity for that monoid. That's the instance in use here.
	&lt;/p&gt;
	&lt;p&gt;
		Just as &lt;code&gt;EitherFix&lt;/code&gt; is &lt;code&gt;Bifoldable&lt;/code&gt;, it's also &lt;code&gt;Bitraversable&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Bitraversable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;bitraverse&amp;nbsp;fl&amp;nbsp;fr&amp;nbsp;=&amp;nbsp;eitherF&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;leftF&amp;nbsp;.&amp;nbsp;fl)&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;rightF&amp;nbsp;.&amp;nbsp;fr)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can comfortably implement the &lt;code&gt;Traversable&lt;/code&gt; instance based on the &lt;code&gt;Bitraversable&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Traversable&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;sequenceA&amp;nbsp;=&amp;nbsp;bisequenceA&amp;nbsp;.&amp;nbsp;first&amp;nbsp;pure&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Finally, you can implement conversions to and from the standard &lt;code&gt;Either&lt;/code&gt; type, using &lt;code&gt;ana&lt;/code&gt; as the dual of &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;toEither&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;l&amp;nbsp;r&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Either&lt;/span&gt;&amp;nbsp;l&amp;nbsp;r
toEither&amp;nbsp;=&amp;nbsp;eitherF&amp;nbsp;Left&amp;nbsp;Right
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;fromEither&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Either&lt;/span&gt;&amp;nbsp;a&amp;nbsp;b&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;EitherFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;b
fromEither&amp;nbsp;=&amp;nbsp;EitherFix&amp;nbsp;.&amp;nbsp;ana&amp;nbsp;coalg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;coalg&amp;nbsp;&amp;nbsp;(Left&amp;nbsp;l)&amp;nbsp;=&amp;nbsp;&amp;nbsp;LeftF&amp;nbsp;l
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;coalg&amp;nbsp;(Right&amp;nbsp;r)&amp;nbsp;=&amp;nbsp;RightF&amp;nbsp;r&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This demonstrates that &lt;code&gt;EitherFix&lt;/code&gt; is isomorphic to &lt;code&gt;Either&lt;/code&gt;, which again establishes that &lt;code&gt;eitherF&lt;/code&gt; and &lt;code&gt;either&lt;/code&gt; are equivalent.
	&lt;/p&gt;
	&lt;h3 id=&quot;00a274a2317548538521d4a171191230&quot;&gt;
		Relationships &lt;a href=&quot;#00a274a2317548538521d4a171191230&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		In this series, you've seen various examples of catamorphisms of structures that have no folds, catamorphisms that coincide with folds, and now a catamorphism that is more general than the fold. The introduction to the series included this diagram:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/catamorphism-and-fold-relations.png&quot; alt=&quot;Catamorphisms and folds as sets, for various sum types.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This shows that Boolean values and Peano numbers have catamorphisms, but no folds, whereas for Maybe and List, the fold and the catamorphism is the same. For Either, however, the fold is a special case of the catamorphism. The fold for Either 'pretends' that the left side doesn't exist. Instead, the left value is interpreted as a missing right value. Thus, in order to fold Either values, you must supply a 'fallback' value that will be used in case an Either value isn't a &lt;em&gt;right&lt;/em&gt; value:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix Either&amp;gt; e = rightF LT :: EitherFix Integer Ordering
Prelude Fix Either&amp;gt; foldr (const . show) &quot;&quot; e
&quot;LT&quot;
Prelude Fix Either&amp;gt; e = leftF 42 :: EitherFix Integer Ordering
Prelude Fix Either&amp;gt; foldr (const . show) &quot;&quot; e
&quot;&quot;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In a GHCi session like the above, you can create two Either values of the same type. The &lt;em&gt;right&lt;/em&gt; case is an &lt;code&gt;Ordering&lt;/code&gt; value, while the &lt;em&gt;left&lt;/em&gt; case is an &lt;code&gt;Integer&lt;/code&gt; value.
	&lt;/p&gt;
	&lt;p&gt;
		With &lt;code&gt;foldr&lt;/code&gt;, there's no way to access the &lt;em&gt;left&lt;/em&gt; case. While you can access and transform the right &lt;code&gt;Ordering&lt;/code&gt; value, the number &lt;code&gt;42&lt;/code&gt; is simply ignored during the fold. Instead, the default value &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned.
	&lt;/p&gt;
	&lt;p&gt;
		Contrast this with the catamorphism, which can access both cases:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix Either&amp;gt; e = rightF LT :: EitherFix Integer Ordering
Prelude Fix Either&amp;gt; eitherF show show e
&quot;LT&quot;
Prelude Fix Either&amp;gt; e = leftF 42 :: EitherFix Integer Ordering
Prelude Fix Either&amp;gt; eitherF show show e
&quot;42&quot;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In a session like this, you recreate the same values, but using the catamorphism &lt;code&gt;eitherF&lt;/code&gt;, you can now access and transform both the &lt;em&gt;left&lt;/em&gt; and the &lt;em&gt;right&lt;/em&gt; cases. In other words, the catamorphism enables you to perform operations not possible with the fold.
	&lt;/p&gt;
	&lt;p&gt;
		It's interesting, however, to note that while the fold is a specialisation of the catamorphism, the &lt;em&gt;bifold&lt;/em&gt; is identical to the catamorphism.
	&lt;/p&gt;
	&lt;h3 id=&quot;7512bca753b747ad9accde04bf13b6ca&quot;&gt;
		Summary &lt;a href=&quot;#7512bca753b747ad9accde04bf13b6ca&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The catamorphism for Either is a pair of functions. One function transforms the &lt;em&gt;left&lt;/em&gt; case, while the other function transforms the &lt;em&gt;right&lt;/em&gt; case. For any Either value, only one of those functions will be used.
	&lt;/p&gt;
	&lt;p&gt;
		When I originally encountered the concept of a &lt;em&gt;catamorphism&lt;/em&gt;, I found it difficult to distinguish between catamorphism and fold. My problem was, I think, that the tutorials I ran into mostly used linked lists to demonstrate how, &lt;a href=&quot;/2019/05/27/list-catamorphism&quot;&gt;in that case&lt;/a&gt;, the fold &lt;em&gt;is&lt;/em&gt; the catamorphism. It turns out, however, that this isn't always the case. A catamorphism is a general abstraction. A fold, on the other hand, seems to me to be mostly related to collections.
	&lt;/p&gt;
	&lt;p&gt;
		In this article you saw the first example of a catamorphism that can do more than the fold. For Either, the fold is just a special case of the catamorphism. You also saw, however, how the catamorphism was identical to the &lt;em&gt;bifold&lt;/em&gt;. Thus, it's still not entirely clear how these concepts relate. Therefore, in the next article, you'll get an example of a &lt;a href=&quot;https://bartoszmilewski.com/2014/01/14/functors-are-containers&quot;&gt;container&lt;/a&gt; where there's no bifold, and where the catamorphism is, indeed, a generalisation of the fold.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;strong&gt;Next:&lt;/strong&gt; &lt;a href=&quot;/2019/06/10/tree-catamorphism&quot;&gt;Tree catamorphism&lt;/a&gt;.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/06/03/either-catamorphism</guid>
      </item>
    
      <item>
        <title>List catamorphism</title>
        <link>https://blog.ploeh.dk/2019/05/27/list-catamorphism/</link>
        <pubDate>Mon, 27 May 2019 06:10:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;The catamorphism for a list is the same as its fold.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This article is part of an &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;article series about catamorphisms&lt;/a&gt;. A catamorphism is a &lt;a href=&quot;/2017/10/04/from-design-patterns-to-category-theory&quot;&gt;universal abstraction&lt;/a&gt; that describes how to digest a data structure into a potentially more compact value.
	&lt;/p&gt;
	&lt;p&gt;
		This article presents the catamorphism for (linked) lists, and other collections in general. It also shows how to identify it. The beginning of this article presents the catamorphism in C#, with an example. The rest of the article describes how to deduce the catamorphism. This part of the article presents my work in &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;. Readers not comfortable with Haskell can just read the first part, and consider the rest of the article as an optional appendix.
	&lt;/p&gt;
	&lt;p&gt;
		The C# part of the article will discuss &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, while the Haskell part will deal specifically with linked lists. Since C# is a less strict language anyway, we have to make some concessions when we consider how concepts translate. In my experience, the functionality of &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; closely mirrors that of Haskell lists.
	&lt;/p&gt;
	&lt;h3 id=&quot;3190f7181a954b6388d77f61a1dbb928&quot;&gt;
		C# catamorphism &lt;a href=&quot;#3190f7181a954b6388d77f61a1dbb928&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The .NET base class library defines this &lt;a href=&quot;https://docs.microsoft.com/dotnet/api/system.linq.enumerable.aggregate&quot;&gt;Aggregate&lt;/a&gt; overload:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;public&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;static&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TAccumulate&lt;/span&gt;&amp;nbsp;Aggregate&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TSource&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TAccumulate&lt;/span&gt;&amp;gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;this&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;IEnumerable&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TSource&lt;/span&gt;&amp;gt;&amp;nbsp;source,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TAccumulate&lt;/span&gt;&amp;nbsp;seed,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TAccumulate&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TSource&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TAccumulate&lt;/span&gt;&amp;gt;&amp;nbsp;func);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This is the catamorphism for linked lists (and, I'll conjecture, for &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; in general). The &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;introductory article&lt;/a&gt; already used it to show several motivating examples, of which I'll only repeat the last:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; &lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;[]&amp;nbsp;{&amp;nbsp;42,&amp;nbsp;1337,&amp;nbsp;2112,&amp;nbsp;90125,&amp;nbsp;5040,&amp;nbsp;7,&amp;nbsp;1984&amp;nbsp;}
. .Aggregate(&lt;span style=&quot;color:#2b91af;&quot;&gt;Angle&lt;/span&gt;.Identity,&amp;nbsp;(a,&amp;nbsp;i)&amp;nbsp;=&amp;gt;&amp;nbsp;a.Add(&lt;span style=&quot;color:#2b91af;&quot;&gt;Angle&lt;/span&gt;.FromDegrees(i)))
[{ Angle = 207° }]&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In short, the catamorphism is, similar to the previous catamorphisms covered in this article series, a pair made from an initial value and a function. This has been true for both the &lt;a href=&quot;/2019/05/13/peano-catamorphism&quot;&gt;Peano catamorphism&lt;/a&gt; and the &lt;a href=&quot;/2019/05/20/maybe-catamorphism&quot;&gt;Maybe catamorphism&lt;/a&gt;. An initial value is just a value in all three cases, but you may notice that the function in question becomes increasingly elaborate. For &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, it's a function that takes two values. One of the values are of the type of the input list, i.e. for &lt;code&gt;IEnumerable&amp;lt;TSource&amp;gt;&lt;/code&gt; it would be &lt;code&gt;TSource&lt;/code&gt;. By elimination you can deduce that this value must come from the input list. The other value is of the type &lt;code&gt;TAccumulate&lt;/code&gt;, which implies that it could be the &lt;code&gt;seed&lt;/code&gt;, or the result from a previous call to &lt;code&gt;func&lt;/code&gt;.
	&lt;/p&gt;
	&lt;h3 id=&quot;46afb325e03743d9ac2c2cf391607f82&quot;&gt;
		List F-Algebra &lt;a href=&quot;#46afb325e03743d9ac2c2cf391607f82&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As in the &lt;a href=&quot;/2019/05/20/maybe-catamorphism&quot;&gt;previous article&lt;/a&gt;, I'll use &lt;code&gt;Fix&lt;/code&gt; and &lt;code&gt;cata&lt;/code&gt; as explained in &lt;a href=&quot;https://bartoszmilewski.com&quot;&gt;Bartosz Milewski&lt;/a&gt;'s excellent &lt;a href=&quot;https://bartoszmilewski.com/2017/02/28/f-algebras/&quot;&gt;article on F-Algebras&lt;/a&gt;. The &lt;code&gt;ListF&lt;/code&gt; type comes from his article as well, although I've renamed the type arguments:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;ListF&amp;nbsp;a&amp;nbsp;c&amp;nbsp;=&amp;nbsp;NilF&amp;nbsp;|&amp;nbsp;ConsF&amp;nbsp;a&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;ListF&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NilF&amp;nbsp;&amp;nbsp;=&amp;nbsp;NilF
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;(ConsF&amp;nbsp;a&amp;nbsp;c)&amp;nbsp;=&amp;nbsp;ConsF&amp;nbsp;a&amp;nbsp;$&amp;nbsp;f&amp;nbsp;c&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Like I did with &lt;code&gt;MaybeF&lt;/code&gt;, I've named the 'data' type argument &lt;code&gt;a&lt;/code&gt;, and the carrier type &lt;code&gt;c&lt;/code&gt; (for &lt;em&gt;carrier&lt;/em&gt;). Once again, notice that the &lt;code&gt;Functor&lt;/code&gt; instance maps over the carrier type &lt;code&gt;c&lt;/code&gt;; not over the 'data' type &lt;code&gt;a&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		As was also the case when deducing the Maybe catamorphism, Haskell isn't too happy about defining instances for a type like &lt;code&gt;Fix (ListF a)&lt;/code&gt;. To address that problem, you can introduce a &lt;code&gt;newtype&lt;/code&gt; wrapper:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;newtype&lt;/span&gt;&amp;nbsp;ListFix&amp;nbsp;a&amp;nbsp;=&amp;nbsp;ListFix&amp;nbsp;{&amp;nbsp;unListFix&amp;nbsp;::&amp;nbsp;Fix&amp;nbsp;(ListF&amp;nbsp;a)&amp;nbsp;}&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can define &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Monad&lt;/code&gt;, etc. instances for this type without resorting to any funky GHC extensions. Keep in mind that ultimately, the purpose of all this code is just to figure out what the catamorphism looks like. This code isn't intended for actual use.
	&lt;/p&gt;
	&lt;p&gt;
		A few helper functions make it easier to define &lt;code&gt;ListFix&lt;/code&gt; values:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;nilF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a
nilF&amp;nbsp;=&amp;nbsp;ListFix&amp;nbsp;$&amp;nbsp;Fix&amp;nbsp;NilF
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;consF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a
consF&amp;nbsp;x&amp;nbsp;=&amp;nbsp;ListFix&amp;nbsp;.&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;ConsF&amp;nbsp;x&amp;nbsp;.&amp;nbsp;unListFix&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		With those functions, you can create &lt;code&gt;ListFix&lt;/code&gt; linked lists:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix List&amp;gt; nilF
ListFix {unListFix = Fix NilF}
Prelude Fix List&amp;gt; consF 42 $ consF 1337 $ consF 2112 nilF
ListFix {unListFix = Fix (ConsF 42 (Fix (ConsF 1337 (Fix (ConsF 2112 (Fix NilF))))))}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The first example creates an empty list, whereas the second creates a list of three integers, corresponding to &lt;code&gt;[42,1337,2112]&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		That's all you need to identify the catamorphism.
	&lt;/p&gt;
	&lt;h3 id=&quot;db44e85b27fb40d0b570c53cf4ce1843&quot;&gt;
		Haskell catamorphism &lt;a href=&quot;#db44e85b27fb40d0b570c53cf4ce1843&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		At this point, you have two out of three elements of an F-Algebra. You have an endofunctor (&lt;code&gt;ListF&lt;/code&gt;), and an object &lt;code&gt;a&lt;/code&gt;, but you still need to find a morphism &lt;code&gt;ListF a c -&amp;gt; c&lt;/code&gt;. Notice that the algebra you have to find is the function that reduces the functor to its &lt;em&gt;carrier type&lt;/em&gt; &lt;code&gt;c&lt;/code&gt;, not the 'data type' &lt;code&gt;a&lt;/code&gt;. This takes some time to get used to, but that's how catamorphisms work. This doesn't mean, however, that you get to ignore &lt;code&gt;a&lt;/code&gt;, as you'll see.
	&lt;/p&gt;
	&lt;p&gt;
		As in the previous article, start by writing a function that will become the catamorphism, based on &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;listF&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unListFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NilF&amp;nbsp;&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(ConsF&amp;nbsp;h&amp;nbsp;t)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While this compiles, with its &lt;code&gt;undefined&lt;/code&gt; implementations, it obviously doesn't do anything useful. I find, however, that it helps me think. How can you return a value of the type &lt;code&gt;c&lt;/code&gt; from the &lt;code&gt;NilF&lt;/code&gt; case? You could pass an argument to the &lt;code&gt;listF&lt;/code&gt; function:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;listF&amp;nbsp;n&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unListFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NilF&amp;nbsp;&amp;nbsp;=&amp;nbsp;n
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(ConsF&amp;nbsp;h&amp;nbsp;t)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;ConsF&lt;/code&gt; case, contrary to &lt;code&gt;NilF&lt;/code&gt;, contains both a head &lt;code&gt;h&lt;/code&gt; (of type &lt;code&gt;a&lt;/code&gt;) and a tail &lt;code&gt;t&lt;/code&gt; (of type &lt;code&gt;c&lt;/code&gt;). While you could make the code compile by simply returning &lt;code&gt;t&lt;/code&gt;, it'd be incorrect to ignore &lt;code&gt;h&lt;/code&gt;. In order to deal with both, you'll need a function that turns both &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; into a value of the type &lt;code&gt;c&lt;/code&gt;. You can do this by passing a function to &lt;code&gt;listF&lt;/code&gt; and using it:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;listF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;(a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
listF&amp;nbsp;f&amp;nbsp;n&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unListFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NilF&amp;nbsp;&amp;nbsp;=&amp;nbsp;n
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(ConsF&amp;nbsp;h&amp;nbsp;t)&amp;nbsp;=&amp;nbsp;f&amp;nbsp;h&amp;nbsp;t&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This works. Since &lt;code&gt;cata&lt;/code&gt; has the type &lt;code&gt;Functor f =&amp;gt; (f a -&amp;gt; a) -&amp;gt; Fix f -&amp;gt; a&lt;/code&gt;, that means that &lt;code&gt;alg&lt;/code&gt; has the type &lt;code&gt;f a -&amp;gt; a&lt;/code&gt;. In the case of &lt;code&gt;ListF&lt;/code&gt;, the compiler infers that the &lt;code&gt;alg&lt;/code&gt; function has the type &lt;code&gt;ListF a c -&amp;gt; c&lt;/code&gt;, which is just what you need!
	&lt;/p&gt;
	&lt;p&gt;
		You can now see what the carrier type &lt;code&gt;c&lt;/code&gt; is for. It's the type that the algebra extracts, and thus the type that the catamorphism returns.
	&lt;/p&gt;
	&lt;p&gt;
		This, then, is the catamorphism for lists. As has been consistent so far, it's a pair made from an initial value and a function. Once more, this isn't the only possible catamorphism, since you can, for example, trivially flip the arguments to &lt;code&gt;listF&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;listF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;(a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
listF&amp;nbsp;n&amp;nbsp;f&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unListFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NilF&amp;nbsp;&amp;nbsp;=&amp;nbsp;n
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(ConsF&amp;nbsp;h&amp;nbsp;t)&amp;nbsp;=&amp;nbsp;f&amp;nbsp;h&amp;nbsp;t&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can also flip the arguments of &lt;code&gt;f&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;listF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;(c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
listF&amp;nbsp;n&amp;nbsp;f&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unListFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;NilF&amp;nbsp;&amp;nbsp;=&amp;nbsp;n
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(ConsF&amp;nbsp;h&amp;nbsp;t)&amp;nbsp;=&amp;nbsp;f&amp;nbsp;t&amp;nbsp;h&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		These representations are all isomorphic to each other, but notice that the last variation is similar to the above C# &lt;code&gt;Aggregate&lt;/code&gt; overload. The initial &lt;code&gt;n&lt;/code&gt; value is the &lt;code&gt;seed&lt;/code&gt;, and the function &lt;code&gt;f&lt;/code&gt; has the same shape as &lt;code&gt;func&lt;/code&gt;. Thus, I consider it reasonable to conjecture that that &lt;code&gt;Aggregate&lt;/code&gt; overload is the catamorphism for &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;.
	&lt;/p&gt;
	&lt;h3 id=&quot;3ba9143e87544443b713727eb4ea60ba&quot;&gt;
		Basis &lt;a href=&quot;#3ba9143e87544443b713727eb4ea60ba&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can implement most other useful functionality with &lt;code&gt;listF&lt;/code&gt;. The rest of this article uses the first of the variations shown above, with the type &lt;code&gt;(a -&amp;gt; c -&amp;gt; c) -&amp;gt; c -&amp;gt; ListFix a -&amp;gt; c&lt;/code&gt;. Here's the &lt;code&gt;Semigroup&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Semigroup&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;xs&amp;nbsp;&amp;lt;&amp;gt;&amp;nbsp;ys&amp;nbsp;=&amp;nbsp;listF&amp;nbsp;consF&amp;nbsp;ys&amp;nbsp;xs&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The initial value passed to &lt;code&gt;listF&lt;/code&gt; is &lt;code&gt;ys&lt;/code&gt;, and the function to apply is simply the &lt;code&gt;consF&lt;/code&gt; function, thus 'consing' the two lists together. Here's an example of the operation in action:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix List&amp;gt; consF 42 $ consF 1337 nilF &amp;lt;&amp;gt; (consF 2112 $ consF 1 nilF)
ListFix {unListFix = Fix (ConsF 42 (Fix (ConsF 1337 (Fix (ConsF 2112 (Fix (ConsF 1 (Fix NilF))))))))}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		With a &lt;code&gt;Semigroup&lt;/code&gt; instance, it's trivial to also implement the &lt;code&gt;Monoid&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Monoid&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;mempty&amp;nbsp;=&amp;nbsp;nilF&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While you &lt;em&gt;could&lt;/em&gt; implement &lt;code&gt;mempty&lt;/code&gt; with &lt;code&gt;listF&lt;/code&gt; (&lt;code&gt;mempty = listF (const id) nilF nilF&lt;/code&gt;), that'd be overcomplicated. Just because you can implement all functionality using &lt;code&gt;listF&lt;/code&gt;, it doesn't mean that you should, if a simpler alternative exists.
	&lt;/p&gt;
	&lt;p&gt;
		You can, on the other hand, use &lt;code&gt;listF&lt;/code&gt; for the &lt;code&gt;Functor&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;=&amp;nbsp;listF&amp;nbsp;(\h&amp;nbsp;l&amp;nbsp;-&amp;gt;&amp;nbsp;consF&amp;nbsp;(f&amp;nbsp;h)&amp;nbsp;l)&amp;nbsp;nilF&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You could write the function you pass to &lt;code&gt;listF&lt;/code&gt; in a point-free fashion as &lt;code&gt;consF . f&lt;/code&gt;, but I thought it'd be easier to follow what happens when written as an explicit lambda expression. The function receives a 'current value' &lt;code&gt;h&lt;/code&gt;, as well as the part of the list which has already been translated &lt;code&gt;l&lt;/code&gt;. Use &lt;code&gt;f&lt;/code&gt; to translate &lt;code&gt;h&lt;/code&gt;, and &lt;code&gt;consF&lt;/code&gt; the result unto &lt;code&gt;l&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		You can add &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Monad&lt;/code&gt; instances in a similar fashion:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Applicative&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;pure&amp;nbsp;x&amp;nbsp;=&amp;nbsp;consF&amp;nbsp;x&amp;nbsp;nilF
&amp;nbsp;&amp;nbsp;fs&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;xs&amp;nbsp;=&amp;nbsp;listF&amp;nbsp;(\f&amp;nbsp;acc&amp;nbsp;-&amp;gt;&amp;nbsp;(f&amp;nbsp;&amp;lt;$&amp;gt;&amp;nbsp;xs)&amp;nbsp;&amp;lt;&amp;gt;&amp;nbsp;acc)&amp;nbsp;nilF&amp;nbsp;fs
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Monad&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;xs&amp;nbsp;&amp;gt;&amp;gt;=&amp;nbsp;f&amp;nbsp;=&amp;nbsp;listF&amp;nbsp;(\x&amp;nbsp;acc&amp;nbsp;-&amp;gt;&amp;nbsp;f&amp;nbsp;x&amp;nbsp;&amp;lt;&amp;gt;&amp;nbsp;acc)&amp;nbsp;nilF&amp;nbsp;xs&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		What may be more interesting, however, is the &lt;code&gt;Foldable&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Foldable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;foldr&lt;/span&gt;&amp;nbsp;=&amp;nbsp;listF&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The demonstrates that &lt;code&gt;listF&lt;/code&gt; and &lt;code&gt;foldr&lt;/code&gt; is the same.
	&lt;/p&gt;
	&lt;p&gt;
		Next, you can also add a &lt;code&gt;Traversable&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Traversable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;sequenceA&amp;nbsp;=&amp;nbsp;listF&amp;nbsp;(\x&amp;nbsp;acc&amp;nbsp;-&amp;gt;&amp;nbsp;consF&amp;nbsp;&amp;lt;$&amp;gt;&amp;nbsp;x&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;acc)&amp;nbsp;(pure&amp;nbsp;nilF)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Finally, you can implement conversions to and from the standard list &lt;code&gt;[]&lt;/code&gt; type, using &lt;code&gt;ana&lt;/code&gt; as the dual of &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;toList&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;[a]
toList&amp;nbsp;=&amp;nbsp;listF&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;(:)&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;[]&lt;/span&gt;
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;fromList&lt;/span&gt;&amp;nbsp;::&amp;nbsp;[a]&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;ListFix&lt;/span&gt;&amp;nbsp;a
fromList&amp;nbsp;=&amp;nbsp;ListFix&amp;nbsp;.&amp;nbsp;ana&amp;nbsp;coalg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;coalg&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;[]&lt;/span&gt;&amp;nbsp;&amp;nbsp;=&amp;nbsp;NilF
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;coalg&amp;nbsp;(h:t)&amp;nbsp;=&amp;nbsp;ConsF&amp;nbsp;h&amp;nbsp;t&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This demonstrates that &lt;code&gt;ListFix&lt;/code&gt; is isomorphic to &lt;code&gt;[]&lt;/code&gt;, which again establishes that &lt;code&gt;listF&lt;/code&gt; and &lt;code&gt;foldr&lt;/code&gt; are equivalent.
	&lt;/p&gt;
	&lt;h3 id=&quot;616c31c72b1f43cca647760d9fa8b226&quot;&gt;
		Summary &lt;a href=&quot;#616c31c72b1f43cca647760d9fa8b226&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The catamorphism for lists is a pair made from an initial value and a function. One variation is equal to &lt;code&gt;foldr&lt;/code&gt;. Like Maybe, the catamorphism is the same as the fold.
	&lt;/p&gt;
	&lt;p&gt;
		In C#, this function corresponds to the &lt;code&gt;Aggregate&lt;/code&gt; extension method identified above.
	&lt;/p&gt;
	&lt;p&gt;
		You've now seen two examples where the catamorphism coincides with the fold. You've also seen examples (&lt;a href=&quot;/2019/05/06/boolean-catamorphism&quot;&gt;Boolean catamorphism&lt;/a&gt; and &lt;a href=&quot;/2019/05/13/peano-catamorphism&quot;&gt;Peano catamorphism&lt;/a&gt;) where there's a catamorphism, but no fold at all. In the next article, you'll see an example of a &lt;a href=&quot;https://bartoszmilewski.com/2014/01/14/functors-are-containers&quot;&gt;container&lt;/a&gt; that has both catamorphism and fold, but where the catamorphism is more general than the fold.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;strong&gt;Next:&lt;/strong&gt; &lt;a href=&quot;/2019/06/03/either-catamorphism&quot;&gt;Either catamorphism&lt;/a&gt;.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/05/27/list-catamorphism</guid>
      </item>
    
      <item>
        <title>Maybe catamorphism</title>
        <link>https://blog.ploeh.dk/2019/05/20/maybe-catamorphism/</link>
        <pubDate>Mon, 20 May 2019 06:04:00 UTC</pubDate>
        <description>


&lt;div id=&quot;post&quot;&gt;
	&lt;p&gt;
		&lt;em&gt;The catamorphism for Maybe is just a simplification of its fold.&lt;/em&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This article is part of an &lt;a href=&quot;/2019/04/29/catamorphisms&quot;&gt;article series about catamorphisms&lt;/a&gt;. A catamorphism is a &lt;a href=&quot;/2017/10/04/from-design-patterns-to-category-theory&quot;&gt;universal abstraction&lt;/a&gt; that describes how to digest a data structure into a potentially more compact value.
	&lt;/p&gt;
	&lt;p&gt;
		This article presents the catamorphism for &lt;a href=&quot;/2018/03/26/the-maybe-functor&quot;&gt;Maybe&lt;/a&gt;, as well as how to identify it. The beginning of this article presents the catamorphism in C#, with examples. The rest of the article describes how to deduce the catamorphism. This part of the article presents my work in &lt;a href=&quot;https://www.haskell.org&quot;&gt;Haskell&lt;/a&gt;. Readers not comfortable with Haskell can just read the first part, and consider the rest of the article as an optional appendix.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;em&gt;Maybe&lt;/em&gt; is a &lt;a href=&quot;https://bartoszmilewski.com/2014/01/14/functors-are-containers&quot;&gt;data container&lt;/a&gt; that models the absence or presence of a value. &lt;a href=&quot;/2015/11/13/null-has-no-type-but-maybe-has&quot;&gt;Contrary to null, Maybe has a type&lt;/a&gt;, so offers a sane and reasonable way to model that situation.
	&lt;/p&gt;
	&lt;h3 id=&quot;1feeee3382ff44d182e0a28a33f8f80a&quot;&gt;
		C# catamorphism &lt;a href=&quot;#1feeee3382ff44d182e0a28a33f8f80a&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		This article uses &lt;a href=&quot;/2018/06/04/church-encoded-maybe&quot;&gt;Church-encoded Maybe&lt;/a&gt;. Other, &lt;a href=&quot;/2018/03/26/the-maybe-functor&quot;&gt;alternative implementations of Maybe are possible&lt;/a&gt;. The catamorphism for Maybe is the &lt;code&gt;Match&lt;/code&gt; method:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;(&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;nbsp;nothing,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Func&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;T&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;TResult&lt;/span&gt;&amp;gt;&amp;nbsp;just);&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Like the &lt;a href=&quot;/2019/05/13/peano-catamorphism&quot;&gt;Peano catamorphism&lt;/a&gt;, the Maybe catamorphism is a pair of a value and a function. The &lt;code&gt;nothing&lt;/code&gt; value corresponds to the absence of data, whereas the &lt;code&gt;just&lt;/code&gt; function handles the presence of data.
	&lt;/p&gt;
	&lt;p&gt;
		Given, for example, a Maybe containing a number, you can use &lt;code&gt;Match&lt;/code&gt; to &lt;a href=&quot;/2019/02/04/how-to-get-the-value-out-of-the-monad&quot;&gt;get the value out of the Maybe&lt;/a&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IMaybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;maybe&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Just&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;(42);
&amp;gt; maybe.Match(0,&amp;nbsp;x&amp;nbsp;=&amp;gt;&amp;nbsp;x)
42
&amp;gt; &lt;span style=&quot;color:#2b91af;&quot;&gt;IMaybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;nbsp;maybe&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Nothing&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:blue;&quot;&gt;int&lt;/span&gt;&amp;gt;();
&amp;gt; maybe.Match(0,&amp;nbsp;x&amp;nbsp;=&amp;gt;&amp;nbsp;x)
0&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The functionality is, however, more useful than a simple &lt;em&gt;get-value-or-default&lt;/em&gt; operation. Often, you don't have a good default value for the type potentially wrapped in a Maybe object. In the core of your application architecture, it may not be clear how to deal with, say, the absence of a &lt;code&gt;Reservation&lt;/code&gt; object, whereas at the boundary of your system, it's evident how to convert both absence and presence of data into a unifying type, such as an HTTP response:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;Reservation&lt;/span&gt;&amp;gt;&amp;nbsp;maybe&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:green;&quot;&gt;//&amp;nbsp;...&lt;/span&gt;
&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;&amp;nbsp;maybe
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.Select(r&amp;nbsp;=&amp;gt;&amp;nbsp;Repository.Create(r))
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;.Match&amp;lt;&lt;span style=&quot;color:#2b91af;&quot;&gt;IHttpActionResult&lt;/span&gt;&amp;gt;(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;nothing:&amp;nbsp;Content(
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;HttpStatusCode&lt;/span&gt;.InternalServerError,
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;new&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;HttpError&lt;/span&gt;(&lt;span style=&quot;color:#a31515;&quot;&gt;&amp;quot;Couldn&amp;#39;t&amp;nbsp;accept.&amp;quot;&lt;/span&gt;)),
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;just:&amp;nbsp;id&amp;nbsp;=&amp;gt;&amp;nbsp;Ok(id));&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This enables you to avoid special cases, such as null &lt;code&gt;Reservation&lt;/code&gt; objects, or magic numbers like &lt;code&gt;-1&lt;/code&gt; to indicate the absence of &lt;code&gt;id&lt;/code&gt; values. At the boundary of an HTTP-based application, you know that you must return an HTTP response. That's the unifying type, so you can return &lt;code&gt;200 OK&lt;/code&gt; with a reservation ID in the response body when data is present, and &lt;code&gt;500 Internal Server Error&lt;/code&gt; when data is absent.
	&lt;/p&gt;
	&lt;h3 id=&quot;87d91da8944f4eb5b8b24e9ea20d3e1b&quot;&gt;
		Maybe F-Algebra &lt;a href=&quot;#87d91da8944f4eb5b8b24e9ea20d3e1b&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As in the &lt;a href=&quot;/2019/05/13/peano-catamorphism&quot;&gt;previous article&lt;/a&gt;, I'll use &lt;code&gt;Fix&lt;/code&gt; and &lt;code&gt;cata&lt;/code&gt; as explained in &lt;a href=&quot;https://bartoszmilewski.com&quot;&gt;Bartosz Milewski&lt;/a&gt;'s excellent &lt;a href=&quot;https://bartoszmilewski.com/2017/02/28/f-algebras/&quot;&gt;article on F-Algebras&lt;/a&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		While F-Algebras and fixed points are mostly used for recursive data structures, you can also define an F-Algebra for a non-recursive data structure. You already saw an example of that in the article about &lt;a href=&quot;/2019/05/06/boolean-catamorphism&quot;&gt;Boolean catamorphism&lt;/a&gt;. The difference between Boolean values and Maybe is that the &lt;em&gt;just&lt;/em&gt; case of Maybe carries a value. You can model this as a &lt;code&gt;Functor&lt;/code&gt; with both a carrier type and a type argument for the data that Maybe may contain:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;data&lt;/span&gt;&amp;nbsp;MaybeF&amp;nbsp;a&amp;nbsp;c&amp;nbsp;=&amp;nbsp;NothingF&amp;nbsp;|&amp;nbsp;JustF&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;MaybeF&lt;/span&gt;&amp;nbsp;a)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;&amp;nbsp;NothingF&amp;nbsp;=&amp;nbsp;NothingF
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;_&amp;nbsp;(JustF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;JustF&amp;nbsp;x&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I chose to call the 'data type' &lt;code&gt;a&lt;/code&gt; and the carrier type &lt;code&gt;c&lt;/code&gt; (for &lt;em&gt;carrier&lt;/em&gt;). As was also the case with &lt;code&gt;BoolF&lt;/code&gt;, the &lt;code&gt;Functor&lt;/code&gt; instance ignores the map function because the carrier type is missing from both the &lt;code&gt;NothingF&lt;/code&gt; case and the &lt;code&gt;JustF&lt;/code&gt; case. Like the &lt;code&gt;Functor&lt;/code&gt; instance for &lt;code&gt;BoolF&lt;/code&gt;, it'd seem that nothing happens, but at the type level, this is still a translation from &lt;code&gt;MaybeF a c&lt;/code&gt; to &lt;code&gt;MaybeF a c1&lt;/code&gt;. Not much of a function, perhaps, but definitely an &lt;em&gt;endofunctor&lt;/em&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		In the previous articles, it was possible to work directly with the fixed points of both functors; i.e. &lt;code&gt;Fix BoolF&lt;/code&gt; and &lt;code&gt;Fix NatF&lt;/code&gt;. Haskell isn't happy about attempts to define various instances for &lt;code&gt;Fix (MaybeF a)&lt;/code&gt;, so in order to make this easier, you can define a &lt;code&gt;newtype&lt;/code&gt; wrapper:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;newtype&lt;/span&gt;&amp;nbsp;MaybeFix&amp;nbsp;a&amp;nbsp;=
&amp;nbsp;&amp;nbsp;MaybeFix&amp;nbsp;{&amp;nbsp;unMaybeFix&amp;nbsp;::&amp;nbsp;Fix&amp;nbsp;(MaybeF&amp;nbsp;a)&amp;nbsp;}&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;deriving&lt;/span&gt;&amp;nbsp;(&lt;span style=&quot;color:#2b91af;&quot;&gt;Show&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Eq&lt;/span&gt;,&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Read&lt;/span&gt;)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In order to make it easier to work with &lt;code&gt;MaybeFix&lt;/code&gt; you can add helper functions to create values:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;nothingF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;a
nothingF&amp;nbsp;=&amp;nbsp;MaybeFix&amp;nbsp;$&amp;nbsp;Fix&amp;nbsp;NothingF
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;justF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;a
justF&amp;nbsp;=&amp;nbsp;MaybeFix&amp;nbsp;.&amp;nbsp;Fix&amp;nbsp;.&amp;nbsp;JustF&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can now create &lt;code&gt;MaybeFix&lt;/code&gt; values to your heart's content:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix Maybe&amp;gt; justF 42
MaybeFix {unMaybeFix = Fix (JustF 42)}
Prelude Fix Maybe&amp;gt; nothingF
MaybeFix {unMaybeFix = Fix NothingF}&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		That's all you need to identify the catamorphism.
	&lt;/p&gt;
	&lt;h3 id=&quot;24db4c715d1f4540bd8f87604819952f&quot;&gt;
		Haskell catamorphism &lt;a href=&quot;#24db4c715d1f4540bd8f87604819952f&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		At this point, you have two out of three elements of an F-Algebra. You have an endofunctor (&lt;code&gt;MaybeF&lt;/code&gt;), and an object &lt;code&gt;a&lt;/code&gt;, but you still need to find a morphism &lt;code&gt;MaybeF a c -&amp;gt; c&lt;/code&gt;. Notice that the algebra you have to find is the function that reduces the functor to its &lt;em&gt;carrier type&lt;/em&gt; &lt;code&gt;c&lt;/code&gt;, not the 'data type' &lt;code&gt;a&lt;/code&gt;. This takes some time to get used to, but that's how catamorphisms work. This doesn't mean, however, that you get to ignore &lt;code&gt;a&lt;/code&gt;, as you'll see.
	&lt;/p&gt;
	&lt;p&gt;
		As in the previous article, start by writing a function that will become the catamorphism, based on &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;maybeF&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unMaybeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;NothingF&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(JustF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		While this compiles, with its &lt;code&gt;undefined&lt;/code&gt; implementations, it obviously doesn't do anything useful. I find, however, that it helps me think. How can you return a value of the type &lt;code&gt;c&lt;/code&gt; from the &lt;code&gt;NothingF&lt;/code&gt; case? You could pass an argument to the &lt;code&gt;maybeF&lt;/code&gt; function:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;maybeF&amp;nbsp;n&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unMaybeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;NothingF&amp;nbsp;=&amp;nbsp;n
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(JustF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;undefined&lt;/span&gt;&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;JustF&lt;/code&gt; case, contrary to &lt;code&gt;NothingF&lt;/code&gt;, already contains a value, and it'd be incorrect to ignore it. On the other hand, &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;a&lt;/code&gt;, and you need to return a value of type &lt;code&gt;c&lt;/code&gt;. You'll need a function to perform the conversion, so pass such a function as an argument to &lt;code&gt;maybeF&lt;/code&gt; as well:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;maybeF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;(a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
maybeF&amp;nbsp;n&amp;nbsp;f&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unMaybeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;NothingF&amp;nbsp;=&amp;nbsp;n
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(JustF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;f&amp;nbsp;x&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This works. Since &lt;code&gt;cata&lt;/code&gt; has the type &lt;code&gt;Functor f =&amp;gt; (f a -&amp;gt; a) -&amp;gt; Fix f -&amp;gt; a&lt;/code&gt;, that means that &lt;code&gt;alg&lt;/code&gt; has the type &lt;code&gt;f a -&amp;gt; a&lt;/code&gt;. In the case of &lt;code&gt;MaybeF&lt;/code&gt;, the compiler infers that the &lt;code&gt;alg&lt;/code&gt; function has the type &lt;code&gt;MaybeF a c -&amp;gt; c&lt;/code&gt;, which is just what you need!
	&lt;/p&gt;
	&lt;p&gt;
		You can now see what the carrier type &lt;code&gt;c&lt;/code&gt; is for. It's the type that the algebra extracts, and thus the type that the catamorphism returns.
	&lt;/p&gt;
	&lt;p&gt;
		Notice that &lt;code&gt;maybeF&lt;/code&gt;, like the above C# &lt;code&gt;Match&lt;/code&gt; method, takes as arguments a pair of a value and a function (together with the Maybe value itself). Those are two representations of the same idea. Furthermore, this is nearly identical to the &lt;code&gt;maybe&lt;/code&gt; function in Haskell's &lt;code&gt;Data.Maybe&lt;/code&gt; module. I found if fitting, therefore, to name the function &lt;code&gt;maybeF&lt;/code&gt;.
	&lt;/p&gt;
	&lt;h3 id=&quot;d8a0eed800de48a994085c419b7b5379&quot;&gt;
		Basis &lt;a href=&quot;#d8a0eed800de48a994085c419b7b5379&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		You can implement most other useful functionality with &lt;code&gt;maybeF&lt;/code&gt;. Here's the &lt;code&gt;Functor&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;nothingF&amp;nbsp;(justF&amp;nbsp;.&amp;nbsp;f)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Since &lt;code&gt;fmap&lt;/code&gt; should be a structure-preserving map, you'll have to map the &lt;em&gt;nothing&lt;/em&gt; case to the &lt;em&gt;nothing&lt;/em&gt; case, and &lt;em&gt;just&lt;/em&gt; to &lt;em&gt;just&lt;/em&gt;. When calling &lt;code&gt;maybeF&lt;/code&gt;, you must supply a value for the &lt;em&gt;nothing&lt;/em&gt; case and a function to deal with the &lt;em&gt;just&lt;/em&gt; case. The &lt;em&gt;nothing&lt;/em&gt; case is easy to handle: just use &lt;code&gt;nothingF&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		In the &lt;em&gt;just&lt;/em&gt; case, first apply the function &lt;code&gt;f&lt;/code&gt; to map from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;, and then use &lt;code&gt;justF&lt;/code&gt; to wrap the &lt;code&gt;b&lt;/code&gt; value in a new &lt;code&gt;MaybeFix&lt;/code&gt; container to get &lt;code&gt;MaybeFix b&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;code&gt;Applicative&lt;/code&gt; is a little harder, but not much:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Applicative&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;pure&amp;nbsp;=&amp;nbsp;justF
&amp;nbsp;&amp;nbsp;f&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;x&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;nothingF&amp;nbsp;(&amp;lt;$&amp;gt;&amp;nbsp;x)&amp;nbsp;f&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;pure&lt;/code&gt; function is just &lt;em&gt;justF&lt;/em&gt; (pun intended). The &lt;em&gt;apply&lt;/em&gt; operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; is more complex.
	&lt;/p&gt;
	&lt;p&gt;
		Both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; surrounding &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; are &lt;code&gt;MaybeFix&lt;/code&gt; values: &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;MaybeFix (a -&amp;gt; b)&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;MaybeFix a&lt;/code&gt;. While it's becoming increasingly clear that you can use a catamorphism like &lt;code&gt;maybeF&lt;/code&gt; to implement most other functionality, to which &lt;code&gt;MaybeFix&lt;/code&gt; value should you apply it? To &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;?
	&lt;/p&gt;
	&lt;p&gt;
		Both are possible, but the code looks (in my opinion) more readable if you apply it to &lt;code&gt;f&lt;/code&gt;. Again, when &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;nothing&lt;/em&gt;, return &lt;code&gt;nothingF&lt;/code&gt;. When &lt;code&gt;f&lt;/code&gt; is &lt;em&gt;just&lt;/em&gt;, use the functor instance to map &lt;code&gt;x&lt;/code&gt; (using the infix &lt;code&gt;fmap&lt;/code&gt; alias &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;).
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Monad&lt;/code&gt; instance, on the other hand, is almost trivial:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Monad&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;gt;&amp;gt;=&amp;nbsp;f&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;nothingF&amp;nbsp;f&amp;nbsp;x&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		As usual, map &lt;em&gt;nothing&lt;/em&gt; to &lt;em&gt;nothing&lt;/em&gt; by supplying &lt;code&gt;nothingF&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; is already a function that returns a &lt;code&gt;MaybeFix b&lt;/code&gt; value, so just use that.
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;Foldable&lt;/code&gt; instance is likewise trivial (although, as you'll see below, you can make it even more trivial):
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Foldable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;foldMap&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;mempty&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		The &lt;code&gt;foldMap&lt;/code&gt; function must return a &lt;code&gt;Monoid&lt;/code&gt; instance, so for the &lt;em&gt;nothing&lt;/em&gt; case, simply return the identity, &lt;em&gt;mempty&lt;/em&gt;. Furthermore, &lt;code&gt;foldMap&lt;/code&gt; takes a function &lt;code&gt;a -&amp;gt; m&lt;/code&gt;, but since the &lt;code&gt;foldMap&lt;/code&gt; implementation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Tacit_programming&quot;&gt;point-free&lt;/a&gt;, you can't 'see' that function as an argument.
	&lt;/p&gt;
	&lt;p&gt;
		Finally, for the sake of completeness, here's the &lt;code&gt;Traversable&lt;/code&gt; instance:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Traversable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;sequenceA&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;(pure&amp;nbsp;nothingF)&amp;nbsp;(justF&amp;nbsp;&amp;lt;$&amp;gt;)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		In the &lt;em&gt;nothing&lt;/em&gt; case, you can put &lt;code&gt;nothingF&lt;/code&gt; into the desired &lt;code&gt;Applicative&lt;/code&gt; with &lt;code&gt;pure&lt;/code&gt;. In the &lt;em&gt;just&lt;/em&gt; case you can take advantage of the desired &lt;code&gt;Applicative&lt;/code&gt; being also a &lt;code&gt;Functor&lt;/code&gt; by simply mapping the inner value(s) with &lt;code&gt;justF&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		Since the &lt;code&gt;Applicative&lt;/code&gt; instance for &lt;code&gt;MaybeFix&lt;/code&gt; equals &lt;code&gt;pure&lt;/code&gt; to &lt;code&gt;justF&lt;/code&gt;, you could alternatively write the &lt;code&gt;Traversable&lt;/code&gt; instance like this:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Traversable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;sequenceA&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;(pure&amp;nbsp;nothingF)&amp;nbsp;(pure&amp;nbsp;&amp;lt;$&amp;gt;)&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I like this alternative less, since I find it confusing. The two appearances of &lt;code&gt;pure&lt;/code&gt; relate to two different types. The &lt;code&gt;pure&lt;/code&gt; in &lt;code&gt;pure nothingF&lt;/code&gt; has the type &lt;code&gt;MaybeFix a -&amp;gt; f (MaybeFix a)&lt;/code&gt;, while the &lt;code&gt;pure&lt;/code&gt; in &lt;code&gt;pure&amp;nbsp;&amp;lt;$&amp;gt;&lt;/code&gt; has the type &lt;code&gt;a -&amp;gt; MaybeFix a&lt;/code&gt;!
	&lt;/p&gt;
	&lt;p&gt;
		Both implementations work the same, though:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;Prelude Fix Maybe&amp;gt; sequenceA (justF (&quot;foo&quot;, 42))
(&quot;foo&quot;,MaybeFix {unMaybeFix = Fix (JustF 42)})&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Here, I'm using the &lt;code&gt;Applicative&lt;/code&gt; instance of &lt;code&gt;(,) String&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		Finally, you can implement conversions to and from the standard &lt;code&gt;Maybe&lt;/code&gt; type, using &lt;code&gt;ana&lt;/code&gt; as the dual of &lt;code&gt;cata&lt;/code&gt;:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;toMaybe&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;a
toMaybe&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;Nothing&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;fromMaybe&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;a
fromMaybe&amp;nbsp;=&amp;nbsp;MaybeFix&amp;nbsp;.&amp;nbsp;ana&amp;nbsp;coalg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;coalg&amp;nbsp;&amp;nbsp;Nothing&amp;nbsp;=&amp;nbsp;NothingF
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;coalg&amp;nbsp;(Just&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;JustF&amp;nbsp;x&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This demonstrates that &lt;code&gt;MaybeFix&lt;/code&gt; is isomorphic to &lt;code&gt;Maybe&lt;/code&gt;, which again establishes that &lt;code&gt;maybeF&lt;/code&gt; and &lt;code&gt;maybe&lt;/code&gt; are equivalent.
	&lt;/p&gt;
	&lt;h3 id=&quot;2ec047e5122b4750a10cbe2012285524&quot;&gt;
		Alternatives &lt;a href=&quot;#2ec047e5122b4750a10cbe2012285524&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		As usual, the above &lt;code&gt;maybeF&lt;/code&gt; isn't the only possible catamorphism. A trivial variation is to flip its arguments, but other variations exist.
	&lt;/p&gt;
	&lt;p&gt;
		It's a recurring observation that a catamorphism is just a generalisation of a &lt;em&gt;fold&lt;/em&gt;. In the above code, the &lt;code&gt;Foldable&lt;/code&gt; instance already looked as simple as anyone could desire, but another variation of a catamorphism for Maybe is this gratuitously embellished definition:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;maybeF&lt;/span&gt;&amp;nbsp;::&amp;nbsp;(a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c)&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;c
maybeF&amp;nbsp;f&amp;nbsp;n&amp;nbsp;=&amp;nbsp;cata&amp;nbsp;alg&amp;nbsp;.&amp;nbsp;unMaybeFix
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;alg&amp;nbsp;&amp;nbsp;NothingF&amp;nbsp;=&amp;nbsp;n
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;alg&amp;nbsp;(JustF&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;f&amp;nbsp;x&amp;nbsp;n&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		This variation redundantly passes &lt;code&gt;n&lt;/code&gt; as an argument to &lt;code&gt;f&lt;/code&gt;, thereby changing the type of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;a -&amp;gt; c -&amp;gt; c&lt;/code&gt;. There's no particular motivation for doing this, apart from establishing that this catamorphism is exactly the same as the fold:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Foldable&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;foldr&lt;/span&gt;&amp;nbsp;=&amp;nbsp;maybeF&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can still implement the other instances as well, but the rest of the code suffers in clarity. Here's a few examples:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Functor&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;fmap&lt;/span&gt;&amp;nbsp;f&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;const&lt;/span&gt;&amp;nbsp;.&amp;nbsp;justF&amp;nbsp;.&amp;nbsp;f)&amp;nbsp;nothingF
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Applicative&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;pure&amp;nbsp;=&amp;nbsp;justF
&amp;nbsp;&amp;nbsp;f&amp;nbsp;&amp;lt;*&amp;gt;&amp;nbsp;x&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;const&lt;/span&gt;&amp;nbsp;.&amp;nbsp;(&amp;lt;$&amp;gt;&amp;nbsp;x))&amp;nbsp;nothingF&amp;nbsp;f
 
&lt;span style=&quot;color:blue;&quot;&gt;instance&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;Monad&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;
&amp;nbsp;&amp;nbsp;x&amp;nbsp;&amp;gt;&amp;gt;=&amp;nbsp;f&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;const&lt;/span&gt;&amp;nbsp;.&amp;nbsp;f)&amp;nbsp;nothingF&amp;nbsp;x&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		I find that the need to compose with &lt;code&gt;const&lt;/code&gt; does nothing to improve the readability of the code, so this variation is mostly, I think, of academic interest. It does show, though, that the catamorphism of Maybe is isomorphic to its fold, as the diagram in the overview article indicated:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;img src=&quot;/content/binary/catamorphism-and-fold-relations.png&quot; alt=&quot;Catamorphisms and folds as sets, for various sum types.&quot;&gt;
	&lt;/p&gt;
	&lt;p&gt;
		You can demonstrate that this variation, too, is isomorphic to &lt;code&gt;Maybe&lt;/code&gt; with a set of conversion:
	&lt;/p&gt;
	&lt;p&gt;
		&lt;pre&gt;&lt;span style=&quot;color:#2b91af;&quot;&gt;toMaybe&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;a
toMaybe&amp;nbsp;=&amp;nbsp;maybeF&amp;nbsp;(&lt;span style=&quot;color:blue;&quot;&gt;const&lt;/span&gt;&amp;nbsp;.&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;return&lt;/span&gt;)&amp;nbsp;Nothing
 
&lt;span style=&quot;color:#2b91af;&quot;&gt;fromMaybe&lt;/span&gt;&amp;nbsp;::&amp;nbsp;&lt;span style=&quot;color:#2b91af;&quot;&gt;Maybe&lt;/span&gt;&amp;nbsp;a&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;-&amp;gt;&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;MaybeFix&lt;/span&gt;&amp;nbsp;a
fromMaybe&amp;nbsp;=&amp;nbsp;MaybeFix&amp;nbsp;.&amp;nbsp;ana&amp;nbsp;coalg
&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:blue;&quot;&gt;where&lt;/span&gt;&amp;nbsp;coalg&amp;nbsp;&amp;nbsp;Nothing&amp;nbsp;=&amp;nbsp;NothingF
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;coalg&amp;nbsp;(Just&amp;nbsp;x)&amp;nbsp;=&amp;nbsp;JustF&amp;nbsp;x&lt;/pre&gt;
	&lt;/p&gt;
	&lt;p&gt;
		Only &lt;code&gt;toMaybe&lt;/code&gt; has changed, compared to above; the &lt;code&gt;fromMaybe&lt;/code&gt; function remains the same. The only change to &lt;code&gt;toMaybe&lt;/code&gt; is that the arguments have been flipped, and &lt;code&gt;return&lt;/code&gt; is now composed with &lt;code&gt;const&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		Since (according to &lt;a href=&quot;http://amzn.to/13tGJ0f&quot;&gt;Conceptual Mathematics&lt;/a&gt;) isomorphisms are transitive this means that the two variations of &lt;code&gt;maybeF&lt;/code&gt; are isomorphic. The latter, more complex, variation of &lt;code&gt;maybeF&lt;/code&gt; is identical &lt;code&gt;foldr&lt;/code&gt;, so we can consider the simpler, more frequently encountered variation a simplification of &lt;em&gt;fold&lt;/em&gt;.
	&lt;/p&gt;
	&lt;h3 id=&quot;f88757d425a04e97956d89270b32c0c0&quot;&gt;
		Summary &lt;a href=&quot;#f88757d425a04e97956d89270b32c0c0&quot; title=&quot;permalink&quot;&gt;#&lt;/a&gt;
	&lt;/h3&gt;
	&lt;p&gt;
		The catamorphism for Maybe is the same as its Church encoding: a pair made from a default value and a function. In Haskell's base library, this is simply called &lt;code&gt;maybe&lt;/code&gt;. In the above C# code, it's called &lt;code&gt;Match&lt;/code&gt;.
	&lt;/p&gt;
	&lt;p&gt;
		This function is total, and you can implement any other functionality you need with it. I therefore consider it the canonical representation of Maybe, which is also why it annoys me that most Maybe implementations come equipped with partial functions like &lt;code&gt;fromJust&lt;/code&gt;, or F#'s &lt;code&gt;Option.get&lt;/code&gt;. Those functions shouldn't be part of a sane and reasonable Maybe API. You shouldn't need them.
	&lt;/p&gt;
	&lt;p&gt;
		In this series of articles about catamorphisms, you've now seen the first example of catamorphism and fold coinciding. In the next article, you'll see another such example - probably the most well-known catamorphism example of them all.
	&lt;/p&gt;
	&lt;p&gt;
		&lt;strong&gt;Next:&lt;/strong&gt; &lt;a href=&quot;/2019/05/27/list-catamorphism&quot;&gt;List catamorphism&lt;/a&gt;.
	&lt;/p&gt;
&lt;/div&gt;&lt;hr&gt;
      This blog is totally free, but if you like it, please consider &lt;a href="https://blog.ploeh.dk/support"&gt;supporting it&lt;/a&gt;.</description>
        <author>Mark Seemann</author>
        <guid isPermaLink="false">https://blog.ploeh.dk/2019/05/20/maybe-catamorphism</guid>
      </item>
    

  </channel>
</rss>
